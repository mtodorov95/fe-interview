import type { Question } from "./interfaces"

export const vueQuestions:Question[] = [{"question": "1.   What is VueJS?", "answer": "**Vue.js** is an open-source, progressive Javascript framework for building user interfaces that aim to be incrementally adoptable. The core library of VueJS is focused on the `view layer` only, and is easy to pick up and integrate with other libraries or existing projects.\n\n\n", "code": ""}, {"question": "2.   What are the major features of VueJS?", "answer": "Below are the some of major features available with VueJS\n1. **Virtual DOM:** It uses virtual DOM similar to other existing frameworks such as ReactJS, Ember etc. Virtual DOM is a light-weight in-memory tree representation of the original HTML DOM and updated without affecting the original DOM.\n2. **Components:** Used to create reusable custom elements in VueJS applications.\n3. **Templates:** VueJS provides HTML based templates that bind the DOM with the Vue instance data\n4. **Routing:** Navigation between pages is achieved through vue-router\n5. **Light weight:** VueJS is light weight library compared to other frameworks.\n\n\n", "code": ""}, {"question": "3.   What are the lifecycle methods of VueJS?", "answer": "Lifecycle hooks are a window into how the library you\u2019re using works behind-the-scenes. By using these hooks, you will know when your component is created, added to the DOM, updated, or destroyed. Let's look at lifecycle diagram before going to each lifecycle hook in detail,\n\n<img src=\"https://github.com/sudheerj/vuejs-interview-questions/blob/master/images/lifecycle.png\" width=\"400\" height=\"800\">\n\n1. **Creation(Initialization):**\nCreation Hooks allow you to perform actions before your component has even been added to the DOM. You need to use these hooks if you need to set things up in your component both during client rendering and server rendering. Unlike other hooks, creation hooks are also run during server-side rendering.\n1. beforeCreate:\nThis hook runs at the very initialization of your component. hook observes data and initialization events in your component. Here, data is still not reactive and events that occur during the component\u2019s lifecycle have not been set up yet.\n2. created:\nThis hook is invoked when Vue has set up events and data observation. Here, events are active and access to reactive data is enabled though templates have not yet been mounted or rendered.\n**Note:** Remember that, You will not have access to the DOM or the target mounting element (this.$el) inside of creation hooks\n2. **Mounting(DOM Insertion):**\nMounting hooks are often the most-used hooks and they allow you to access your component immediately before and after the first render.\n1. beforeMount:\nThe beforeMount allows you to access your component immediately before and after the first render.\n2. mounted:\nThis is a most used hook and you will have full access to the reactive component, templates, and rendered DOM (via. this.$el).  The most frequently used patterns are fetching data for your component.\n3. **Updating (Diff & Re-render):**\nUpdating hooks are called whenever a reactive property used by your component changes, or something else causes it to re-render\n1. beforeUpdate:\nThe beforeUpdate hook runs after data changes on your component and the update cycle begins, right before the DOM is patched and re-rendered.\n2. updated:\nThis hook runs after data changes on your component and the DOM re-renders.\n4. **Destruction (Teardown):**\nDestruction hooks allow you to perform actions when your component is destroyed, such as cleanup or analytics sending.\n1. beforeDestroy:\n`beforeDestroy` is fired right before teardown. If you need to cleanup events or reactive subscriptions, beforeDestroy would probably be the time to do it. Your component will still be fully present and functional.\n2. destroyed:\nThis hooks is called after your component has been destroyed, its directives have been unbound and its event listeners have been removed.\n\n\n", "code": "new Vue((\ndata: (\ncount: 10\n),\nbeforeCreate: function () (\nconsole.log('Nothing gets called at this moment')\n// `this` points to the view model instance\nconsole.log('count is ' + this.count);\n)\n))\n// count is undefined\nnew Vue((\ndata: (\ncount: 10\n),\ncreated: function () (\n// `this` points to the view model instance\nconsole.log('count is: ' + this.count)\n)\n))\n// count is: 10\nnew Vue((\nbeforeMount: function () (\n// `this` points to the view model instance\nconsole.log(`this.$el is yet to be created`);\n)\n))\n<div id=\"app\">\n<p>I\u2019m text inside the component.</p>\n</div>\nnew Vue((\nel: \u2018#app\u2019,\nmounted: function() (\nconsole.log(this.$el.textContent); // I'm text inside the component.\n)\n))\n<div id=\"app\">\n<p>((counter))</p>\n</div>\n...// rest of the code\nnew Vue((\nel: '#app',\ndata() (\nreturn (\ncounter: 0\n)\n),\ncreated: function() (\nsetInterval(() => (\nthis.counter++\n), 1000)\n),\n\nbeforeUpdate: function() (\nconsole.log(this.counter) // Logs the counter value every second, before the DOM updates.\n)\n))\n<div id=\"app\">\n<p ref=\"dom\">((counter))</p>\n</div>\n...//\nnew Vue((\nel: '#app',\ndata() (\nreturn (\ncounter: 0\n)\n),\ncreated: function() (\nsetInterval(() => (\nthis.counter++\n), 1000)\n),\nupdated: function() (\nconsole.log(+this.$refs['dom'].textContent === this.counter) // Logs true every second\n)\n))\nnew Vue ((\ndata() (\nreturn (\nmessage: 'Welcome VueJS developers'\n)\n),\n\nbeforeDestroy: function() (\nthis.message = null\ndelete this.message\n)\n))\nnew Vue ((\ndestroyed: function() (\nconsole.log(this) // Nothing to show here\n)\n))\n"}, {"question": "4.   What are the conditional directives?", "answer": "VueJS provides set of directives to show or hide elements based on conditions. The available directives are: **v-if, v-else, v-else-if and v-show**\n\n**1. v-if:**  The v-if directive adds or removes DOM elements based on the given expression. For example, the below button will not show if isLoggedIn is set to false.\nYou can also control multiple elements with a single v-if statement by wrapping all the elements in a `<template>` element with the condition. For example, you can have both label and button together conditionally applied,\n**2. v-else:**  This directive is used to display content only when the expression adjacent v-if resolves to false. This is similar to else block in any programming language to display alternative content and it is preceded by v-if or v-else-if block. You don't need to pass any value to this.\nFor example, v-else is used to display LogIn button if isLoggedIn is set to false(not logged in).\n**3. v-else-if:** This directive is used when we need more than two options to be checked.\nFor example, we want to display some text instead of LogIn button when ifLoginDisabled property is set to true. This can be achieved through v-else statement.\n\n**4. v-show:** This directive is similar to v-if but it renders all elements to the DOM and then uses the CSS display property to show/hide elements. This directive is recommended if the elements are switched on and off frequently.\n\n\n", "code": "<button v-if=\"isLoggedIn\">Logout</button>\n<template v-if=\"isLoggedIn\">\n<label> Logout </button>\n<button> Logout </button>\n</template>\n<button v-if=\"isLoggedIn\"> Logout </button>\n<button v-else> Log In </button>\n<button v-if=\"isLoggedIn\"> Logout </button>\n<label v-else-if=\"isLoginDisabled\"> User login disabled </label>\n<button v-else> Log In </button>\n<span v-show=\"user.name\">Welcome user,((user.name))</span>\n"}, {"question": "5.   What is the difference between v-show and v-if directives?", "answer": "Below are some of the main differences between **v-show** and **v-if** directives,\n\n1. v-if only renders the element to the DOM if the expression passes whereas v-show renders all elements to the DOM and then uses the CSS display property to show/hide elements based on expression.\n2. v-if supports v-else and v-else-if directives whereas v-show doesn't support else directives.\n3. v-if has higher toggle costs while v-show has higher initial render costs. i.e, v-show has a performance advantage if the elements are switched on and off frequently, while the v-if has the advantage when it comes to initial render time.\n4. v-if supports `<template>` tab but v-show doesn't support.\n\n\n", "code": ""}, {"question": "6.   What is the purpose of v-for directive?", "answer": "The built-in v-for directive allows us to loop through items in an array or object. You can iterate on each element in the array or object.\n1. **Array usage:**\nYou can also use `of` as the delimiter instead of `in`, similar to javascript iterators.\n\n2. **Object usage:**\n\n\n", "code": "<ul id=\"list\">\n<li v-for=\"(item, index) in items\">\n(( index )) - (( item.message ))\n</li>\n</ul>\n\nvar vm = new Vue((\nel: '#list',\ndata: (\nitems: [\n( message: 'John' ),\n( message: 'Locke' )\n]\n)\n))\n<div id=\"object\">\n<div v-for=\"(value, key, index) of user\">\n(( index )). (( key )): (( value ))\n</div>\n</div>\n\nvar vm = new Vue((\nel: '#object',\ndata: (\nuser: (\nfirstName: 'John',\nlastName: 'Locke',\nage: 30\n)\n)\n))\n"}, {"question": "7.   What is vue instance?", "answer": "Every Vue application works by creating a new Vue instance with the Vue function. Generally the variable vm (short for ViewModel) is used to refer Vue instance. You can create vue instance as below,\nAs mentioned in the above code snippets, you need to pass options object. You can find the full list of options in the API reference.\n\n\n", "code": "var vm = new Vue((\n// options\n))\n"}, {"question": "8.   How do you achieve conditional group of elements?", "answer": "You can achieve conditional group of elements(toggle multiple elements at a time) by applying **v-if** directive on `<template>` element which works as invisible wrapper(no rendering) for group of elements.\n\nFor example, you can conditionally group user details based on valid user condition.\n\n\n", "code": "<template v-if=\"condition\">\n<h1>Name</h1>\n<p>Address</p>\n<p>Contact Details</p>\n</template>\n"}, {"question": "9.   How do you reuse elements with key attribute?", "answer": "Vue always tries to render elements as efficient as possible. So it tries to reuse the elements instead of building them from scratch. But this behavior may cause problems in few scenarios.\n\nFor example, if you try to render the same input element in both `v-if` and `v-else` blocks then it holds the previous value as below,\nIn this case, it shouldn't reuse. We can make both input elements as separate by applying **key** attribute as below,\nThe above code make sure both inputs are independent and doesn't impact each other.\n\n\n", "code": "<template v-if=\"loginType === 'Admin'\">\n<label>Admin</label>\n<input placeholder=\"Enter your ID\">\n</template>\n<template v-else>\n<label>Guest</label>\n<input placeholder=\"Enter your name\">\n</template>\n<template v-if=\"loginType === 'Admin'\">\n<label>Admin</label>\n<input placeholder=\"Enter your ID\" key=\"admin-id\">\n</template>\n<template v-else>\n<label>Guest</label>\n<input placeholder=\"Enter your name\" key=\"user-name\">\n</template>\n"}, {"question": "10.  Why should not use if and for directives together on the same element?", "answer": "It is recommended not to use v-if on the same element as v-for. Because v-if directive has a higher priority than v-for.\n\nThere are two cases where developers try to use this combination,\n\n1. To filter items in a list\n\nFor example, if you try to filter the list using v-if tag,\n\nThis can be avoided by preparing the filtered list using computed property on the initial list\n2. To avoid rendering a list if it should be hidden\n\nFor example, if you try to conditionally check if the user is to be shown or hidden\n\nThis can be solved by moving the condition to a parent by avoiding this check for each user\n\n\n", "code": "<ul>\n<li\nv-for=\"user in users\"\nv-if=\"user.isActive\"\n:key=\"user.id\"\n>\n(( user.name ))\n<li>\n</ul>\ncomputed: (\nactiveUsers: function () (\nreturn this.users.filter(function (user) (\nreturn user.isActive\n))\n)\n)\n...... //\n...... //\n<ul>\n<li\nv-for=\"user in activeUsers\"\n:key=\"user.id\">\n(( user.name ))\n<li>\n</ul>\n<ul>\n<li\nv-for=\"user in users\"\nv-if=\"shouldShowUsers\"\n:key=\"user.id\"\n>\n(( user.name ))\n<li>\n</ul>\n<ul v-if=\"shouldShowUsers\">\n<li\nv-for=\"user in users\"\n:key=\"user.id\"\n>\n(( user.name ))\n<li>\n</ul>\n"}, {"question": "11.   Why do you need to use key attribute on for directive?", "answer": "In order to track each node\u2019s identity, and thus reuse and reorder existing elements, you need to provide a unique `key` attribute for each item with in `v-for` iteration. An ideal value for key would be the unique id of each item.\n\nLet us take an example usage,\nHence, It is always recommended to provide a key with v-for whenever possible, unless the iterated DOM content is simple.\n\n**Note:** You shouldn\u2019t use non-primitive values like objects and arrays as v-for keys. Use string or numeric values instead.\n\n\n", "code": "<div v-for=\"item in items\" :key=\"item.id\">\n((item.name))\n</div>\n"}, {"question": "12.   What are the array detection mutation methods?", "answer": "As the name suggests, mutation methods modifies the original array.\n\nBelow are the list of array mutation methods which trigger view updates.\n1. push()\n2. pop()\n3. shift()\n4. unshift()\n5. splice()\n6. sort()\n7. reverse()\n\nIf you perform any of the above mutation method on the list then it triggers view update. For example, push method on array named 'items' trigger a view update,\n\n\n", "code": "vm.todos.push(( message: 'Baz' ))\n"}, {"question": "13.   What are the array detection non-mutation methods?", "answer": "The methods which do not mutate the original array but always return a new array are called non-mutation methods.\n\nBelow are the list of non-mutation methods,\n1. filter()\n2. concat()\n3. slice()\n\nFor example, lets take a todo list where it replaces the old array with new one based on status filter,\nThis approach won't re-render the entire list due to VueJS implementation.\n\n\n", "code": "vm.todos = vm.todos.filter(function (todo) (\nreturn todo.status.match(/Completed/)\n))\n"}, {"question": "14.   What are the caveats of array changes detection?", "answer": "Vue cannot detect changes for the array in the below two cases,\n\n1. When you directly set an item with the index,For example,\n2. When you modify the length of the array, For example,\n\nYou can overcome both the caveats using `set` and `splice` methods, Let's see the solutions with an examples,\n\n**First use case solution**\n**Second use case solution**\n\n\n", "code": "vm.todos[indexOfTodo] = newTodo\nvm.todos.length = todosLength\n// Vue.set\nVue.set(vm.todos, indexOfTodo, newTodoValue)\n(or)\n// Array.prototype.splice\nvm.todos.splice(indexOfTodo, 1, newTodoValue)\nvm.todos.splice(todosLength)\n"}, {"question": "15.   What are the caveats of object changes detection?", "answer": "Vue cannot detect changes for the object in property addition or deletion.\n\nLets take an example of user data changes,\nYou can overcome this scenario using the Vue.set(object, key, value) method or Object.assign(),\n\n\n", "code": "var vm = new Vue((\ndata: (\nuser: (\nname: 'John'\n)\n)\n))\n\n// `vm.name` is now reactive\n\nvm.user.email = john@email.com // `vm.user.email` is NOT reactive\nVue.set(vm.user, 'email', 'john@email.com');\n// (or)\nvm.user = Object.assign((), vm.user, (\nemail: john@email.com\n))\n"}, {"question": "16.   How do you use v-for directive with a range?", "answer": "You can also use integer type(say 'n') for `v-for` directive which repeats the element many times.\nIt displays the number 1 to 20.\n\n\n", "code": "<div>\n<span v-for=\"n in 20\">(( n )) </span>\n</div>\n"}, {"question": "17.   How do you use v-for directive on template?", "answer": "Just similar to v-if directive on template, you can also use a `<template>` tag with v-for directive to render a block of multiple elements.\n\nLet's take a todo example,\n\n\n", "code": "<ul>\n<template v-for=\"todo in todos\">\n<li>(( todo.title ))</li>\n<li class=\"divider\"></li>\n</template>\n</ul>\n"}, {"question": "18.   How do you use event handlers?", "answer": "You can use event handlers in vue similar to plain javascript. The method calls also support the special $event variable.\n\n\n", "code": "<button v-on:click=\"show('Welcome to VueJS world', $event)\">\nSubmit\n</button>\n\nmethods: (\nshow: function (message, event) (\n// now we have access to the native event\nif (event) event.preventDefault()\nconsole.log(message);\n)\n)\n"}, {"question": "19.   What are the event modifiers provided by vue?", "answer": "Normally, javascript provides `event.preventDefault() or event.stopPropagation()` inside event handlers. You can use methods provided by vue, but these methods are meant for data logic instead of dealing with DOM events. Vue provides below event modifiers for v-on and these modifiers are directive postfixes denoted by a dot.\n1. .stop\n2. .prevent\n3. .capture\n4. .self\n5. .once\n6. .passive\n\nLet's take an example of stop modifier,\nYou can also chain modifiers as below,\n\n\n", "code": "<!-- the click event's propagation will be stopped -->\n<a v-on:click.stop=\"methodCall\"></a>\n<!-- modifiers can be chained -->\n<a v-on:click.stop.prevent=\"doThat\"></a>\n"}, {"question": "20.   What are key modifiers?", "answer": "Vue supports key modifiers on `v-on` for handling keyboard events. Let's take an example of keyup event with enter keycode.\nRemembering all the key codes is really difficult. It supports the full list of key codes aliases\n1. .enter\n2. .tab\n3. .delete (captures both \u201cDelete\u201d and \u201cBackspace\u201d keys)\n4. .esc\n5. .space\n6. .up\n7. .down\n8. .left\n9. .right\n\nNow the above keyup code snippet can be written with aliases as follows,\n\n**Note:** The use of keyCode events is deprecated and may not be supported in new browsers.\n\n\n", "code": "<!-- only call `vm.show()` when the `keyCode` is 13 -->\n<input v-on:keyup.13=\"show\">\n<input v-on:keyup.enter=\"submit\" />\n<!-- OR with shorthand notation -->\n<input @keyup.enter=\"submit\" />\n"}, {"question": "21.   How do you define custom key modifier aliases?", "answer": "You can define custom key modifier aliases via the global `config.keyCodes`. There are few guidelines for the properties\n1. You can't use camelCase. Instead you can use kebab-case with double quotation marks\n2. You can define multiple values in an array format\n\n\n", "code": "Vue.config.keyCodes = (\nf1: 112,\n\"media-play-pause\": 179,\ndown: [40, 87]\n)\n"}, {"question": "22.   What are the supported System Modifier Keys?", "answer": "Vue supports below modifiers to trigger mouse or keyboard event listeners when the corresponding key is pressed,\n1. .ctrl\n2. .alt\n3. .shift\n4. .meta\n\nLets take an example of control modifier with click event,\n\n\n", "code": "<!-- Ctrl + Click -->\n<div @click.ctrl=\"doSomething\">Do something</div>\n"}, {"question": "23.   What are the supported Mouse Button Modifiers?", "answer": "Vue supports below mouse button modifiers\n1. .left\n2. .right\n3. .middle\n\nFor example, the usage of `.right` modifier as below\n\n\n", "code": "<button\nv-if=\"button === 'right'\"\nv-on:mousedown.right=\"increment\"\nv-on:mousedown.left=\"decrement\"\n/>\n"}, {"question": "24.   How do you implement two-way binding?", "answer": "You can use the `v-model` directive to create two-way data bindings on form input, textarea, and select elements.\n\nLets take an example of it using input component,\nRemember, v-model will ignore the initial `value`, `checked` or `selected` attributes found on any form elements. So it always use the Vue instance data as the source of truth.\n\n\n", "code": "<input v-model=\"message\" placeholder=\"Enter input here\">\n<p>The message is: (( message ))</p>\n"}, {"question": "25.   What are the supported modifiers on model?", "answer": "There are three modifiers supported for v-model directive.\n\n**1. lazy:** By default, v-model syncs the input with the data after each input event. You can add the lazy modifier to instead sync after change events.\n**2. number:** If you want user input to be automatically typecast as a number, you can add the number modifier to your v-model. Even with type=\"number\", the value of HTML input elements always returns a string. So, this typecast modifier is required.\n**3. trim:** If you want whitespace from user input to be trimmed automatically, you can add the trim modifier to your v-model.\n\n\n", "code": "<!-- synced after \"change\" instead of \"input\" -->\n<input v-model.lazy=\"msg\" >\n<input v-model.number=\"age\" type=\"number\">\n<input v-model.trim=\"msg\">\n"}, {"question": "26.   What are components and give an example?", "answer": "Components are reusable Vue instances with a name. They accept the same options as new Vue, such as data, computed, watch, methods, and lifecycle hooks(except few root-specific options like el).\n\nLets take an example of counter component,\nLet's use this component inside a root Vue instance created with new Vue\n\n\n", "code": "// Define a new component called button-counter\nVue.component('button-counter', (\ntemplate: '<button v-on:click=\"count++\">You clicked me (( count )) times.</button>'\ndata: function () (\nreturn (\ncount: 0\n)\n),\n))\n<div id=\"app\">\n<button-counter></button-counter>\n</div>\n\nvar vm = new Vue(( el: '#app' ));\n"}, {"question": "27.   What are props?", "answer": "Props are custom attributes you can register on a component. When a value is passed to a prop attribute, it becomes a property on that component instance. You can pass those list of values as props option and use them as similar to data variables in template.\nOnce the props are registered, you can pass them as custom attributes.\n\n\n", "code": "Vue.component('todo-item', (\nprops: ['title'],\ntemplate: '<h2>(( title ))</h2>'\n))\n<todo-item title=\"Learn Vue conceptsnfirst\"></todo-item>\n"}, {"question": "28.   When component needs a single root element?", "answer": "In VueJS 2.x, every component must have a single root element **when template has more than one element**. In this case, you need to wrap the elements with a parent element.\nOtherwise there will an error throwing, saying that \"Component template should contain exactly one root element...\".\n\nWhereas in 3.x, components now can have multiple root nodes. This way of adding multiple root nodes is called as fragments.\n\n\n", "code": "<template>\n<div class=\"todo-item\">\n<h2>(( title ))</h2>\n<div v-html=\"content\"></div>\n</div>\n</template>\n<template>\n<h2>(( title ))</h2>\n<div v-html=\"content\"></div>\n</template>\n"}, {"question": "29.   How do you communicate from child to parent using events?", "answer": "If you want child wants to communicate back up to the parent, then emit an event from child using `$emit` object to parent,\nNow you can use this todo-item in parent component to access the count value.\n\n\n", "code": "Vue.component('todo-item', (\nprops: ['todo'],\ntemplate: `\n<div class=\"todo-item\">\n<h3>(( todo.title ))</h3>\n<button v-on:click=\"$emit('increment-count', 1)\">\nAdd\n</button>\n<div v-html=\"todo.description\"></div>\n</div>\n`\n))\n<ul v-for=\"todo in todos\">\n<li>\n<todo-item\nv-bind:key=\"todo.id\"\nv-bind:todo=\"todo\"\nv-on:increment-count=\"total += 1\"\n/></todo-item>\n</li>\n</ul>\n<span> Total todos count is ((total))</span>\n"}, {"question": "30.   How do you implement model on custom input components?", "answer": "The custom events can also be used to create custom inputs that work with v-model. The `<input>` inside the component must follow below rules,\n\n1. Bind the value attribute to a value prop\n2. On input, emit its own custom input event with the new value.\n\nLet's take a custom-input component as an example,\nNow you can use `v-model` with this component,\n\n\n", "code": "Vue.component('custom-input', (\nprops: ['value'],\ntemplate: `\n<input\nv-bind:value=\"value\"\nv-on:input=\"$emit('input', $event.target.value)\"\n/>\n`\n))\n<custom-input v-model=\"searchInput\"></custom-input>\n"}, {"question": "31.   What are slots?", "answer": "Vue implements a content distribution API using the <slot> element to serve as distribution outlets for content created after the current Web Components spec draft.\n\nLet's create an alert component with slots for content insertion,\nNow you can insert dynamic content as below,\n\n\n", "code": "Vue.component('alert', (\ntemplate: `\n<div class=\"alert-box\">\n<strong>Error!</strong>\n<slot></slot>\n</div>\n`\n))\n<alert>\nThere is an issue with in application.\n</alert>\n"}, {"question": "32.   What is global registration in components?", "answer": "The components which are globally registered can be used in the template of any root Vue instance (new Vue) created after registration.\n\nIn the global registration, the components created using Vue.component as below,\nLet's take multiple components which are globally registered in the vue instance,\nThe above components can be used in the vue instance,\nRemember that the components can be used in subcomponents as well.\n\n\n", "code": "Vue.component('my-component-name', (\n// ... options ...\n))\nVue.component('component-a', ( /* ... */ ))\nVue.component('component-b', ( /* ... */ ))\nVue.component('component-c', ( /* ... */ ))\n\nnew Vue(( el: '#app' ))\n<div id=\"app\">\n<component-a></component-a>\n<component-b></component-b>\n<component-c></component-c>\n</div>\n"}, {"question": "33.   Why do you need local registration?", "answer": "Due to global registration, even if you don't use the component it could still be included in your final build. So it will create unnecessary javascript in the application. This can be avoided using local registration with the below steps,\n1. First you need to define your components as plain JavaScript objects\nLocally registered components will not be available in sub components. In this case, you need to add them in components section\n2. You can use the components in the components section of the vue instance,\n\n\n", "code": "var ComponentA = ( /* ... */ )\nvar ComponentB = ( /* ... */ )\nvar ComponentC = ( /* ... */ )\nvar ComponentA = ( /* ... */ )\n\nvar ComponentB = (\ncomponents: (\n'component-a': ComponentA\n),\n// ...\n)\nnew Vue((\nel: '#app',\ncomponents: (\n'component-a': ComponentA,\n'component-b': ComponentB\n)\n))\n"}, {"question": "34.   What is the difference between local and global registration in module system?", "answer": "In **local registration**, you need to create each component in components folder(optional but it is recommended) and import them in another component file components section.\n\nLet's say you want to register component A and B in component C, the configuration seems as below,\nNow both ComponentA and ComponentB can be used inside ComponentC\u2018s template.\n\nIn **global registration**, you need to export all common or base components in a separate file. But some of the popular bundlers like `webpack` make this process simpler by using `require.context` to globally register base components in the below entry file(one-time).\n\n\n\n", "code": "import ComponentA from './ComponentA'\nimport ComponentB from './ComponentB'\n\nexport default (\ncomponents: (\nComponentA,\nComponentB\n),\n// ...\n)\nimport Vue from 'vue'\nimport upperFirst from 'lodash/upperFirst'\nimport camelCase from 'lodash/camelCase'\n\nconst requireComponent = require.context(\n// The relative path of the components folder\n'./components',\n// Whether or not to look in subfolders\nfalse,\n// The regular expression used to match base component filenames\n/Base[A-Z]\\w+\\.(vue|js)$/\n)\n\nrequireComponent.keys().forEach(fileName => (\n// Get component config\nconst componentConfig = requireComponent(fileName)\n\n// Get PascalCase name of component\nconst componentName = upperFirst(\ncamelCase(\n// Strip the leading `./` and extension from the filename\nfileName.replace(/^\\.\\/(.*)\\.\\w+$/, '$1')\n)\n)\n\n// Register component globally\nVue.component(\ncomponentName,\n// Look for the component options on `.default`, which will\n// exist if the component was exported with `export default`,\n// otherwise fall back to module's root.\ncomponentConfig.default || componentConfig\n)\n))\n"}, {"question": "35.   What are possible prop types?", "answer": "You can declare props with type or without type. But it is recommended to have prop types because it provides the documentation for the component and warns the developer for any incorrect data type being assigned.\nAs mentioned in the above code snippet, you can list props as an object, where the properties\u2019 names and values contain the prop names and types, respectively.\n\n\n", "code": "props: (\nname: String,\nage: Number,\nisAuthenticated: Boolean,\nphoneNumbers: Array,\naddress: Object\n)\n"}, {"question": "36.   What is the data flow followed by props?", "answer": "All props follows a one-way-down binding between the child property and the parent one. i.e, When the parent property is updated then that latest prop value will be passed down to the child, but not the otherway(child to parent) around. The child component should not mutate the prop otherwise it throws a warning in the console.\nThe possible mutation cases can be solved as below,\n1. When you try to use parent prop as initial value for child property:\n\nIn this case you can define a local property in child component and assign parent value as initial value\n2. When you try to transform the parent prop:\n\nYou can define a computed property using the prop\u2019s value,\n\n\n", "code": "props: ['defaultUser'],\ndata: function () (\nreturn (\nusername: this.defaultUser\n)\n)\nprops: ['environment'],\ncomputed: (\nlocalEnvironment: function () (\nreturn this.environment.trim().toUpperCase()\n)\n)\n"}, {"question": "37.   What are non prop attributes?", "answer": "A non-prop attribute is an attribute that is passed to a component, but does not have a corresponding prop defined.\n\nFor example, If you are using a 3rd-party custom-input component that requires a `data-tooltip` attribute on the input then you can add this attribute to component instance,\nIf you try to pass the props from parent component the child props with the same names will be overridden. But props like `class` and `style` are exception to this, these values will be merged in the child component.\n\n\n", "code": "<custom-input data-tooltip=\"Enter your input\" />\n<!-- Child component -->\n<input type=\"date\" class=\"date-control\">\n\n<!-- Parent component -->\n<custom-input class=\"custom-class\" />\n"}, {"question": "38.   Describe about validations available for props?", "answer": "Vue provides validations such as types, required fields, default values along with customized validations. You can provide an object with validation requirements to the value of props as below,\n\nLet's take an example of user profile Vue component with possible validations,\n\n\n", "code": "Vue.component('user-profile', (\nprops: (\n// Basic type check (`null` matches any type)\nage: Number,\n// Multiple possible types\nidentityNumber: [String, Number],\n// Required string\nemail: (\ntype: String,\nrequired: true\n),\n// Number with a default value\nminBalance: (\ntype: Number,\ndefault: 10000\n),\n// Object with a default value\nmessage: (\ntype: Object,\n// Object or array defaults must be returned from\n// a factory function\ndefault: function () (\nreturn ( message: 'Welcome to Vue' )\n)\n),\n// Custom validator function\nlocation: (\nvalidator: function (value) (\n// The value must match one of these strings\nreturn ['India', 'Singapore', 'Australia'].indexOf(value) !== -1\n)\n)\n)\n))\n"}, {"question": "39.   How do you customize model directive for a component?", "answer": "The v-model directive on a component uses **value** as the prop and **input** as the event, but some input types such as `checkboxes` and `radio buttons` may need to use the value attribute for a server side value. In this case, it is preferred to customize model directive.\n\nLet's take an example of checkbox component,\nNow you can use v-model on this customized component as below,\nThe selectFramework property will be passed to the checked prop and same property will be updated when custom checkbox component emits a change event with a new value.\n\n\n", "code": "Vue.component('custom-checkbox', (\nmodel: (\nprop: 'checked',\nevent: 'change'\n),\nprops: (\nchecked: Boolean\n),\ntemplate: `\n<input\ntype=\"checkbox\"\nv-bind:checked=\"checked\"\nv-on:change=\"$emit('change', $event.target.checked)\"\n>\n`\n))\n<custom-checkbox v-model=\"selectFramework\"></custom-checkbox>\n"}, {"question": "40.   What are the possible ways to provide transitions?", "answer": "There are many ways Vue provides transition effects when items are inserted, updated, or removed from the DOM.\n\nBelow are the possible ways,\n1. Automatically apply classes for CSS transitions and animations\n2. Integrate 3rd-party CSS animation libraries. For example, Animate.css\n3. Use JavaScript to directly manipulate the DOM during transition hooks\n4. Integrate 3rd-party JavaScript animation libraries. For example, Velocity.js\n\n\n", "code": ""}, {"question": "41.   What is vue router and their features?", "answer": "Vue Router is a official routing library for single-page applications designed for use with the Vue.js framework.\n\nBelow are their features,\n1. Nested route/view mapping\n2. Modular, component-based router configuration\n3. Route params, query, wildcards\n4. View transition effects powered by Vue.js' transition system\n5. Fine-grained navigation control\n6. Links with automatic active CSS classes\n7. HTML5 history mode or hash mode, with auto-fallback in IE9\n8. Restore scroll position when going back in history mode\n\n\n", "code": ""}, {"question": "42.   What are the steps to use vue router and give an example?", "answer": "It is easy to integrate vue router in the vue application.\n\nLet us see the example with step by step instructions.\n\n**Step 1:** Configure router link and router view in the template\n\n**Step 2:** Import Vue and VueRouter packages and then apply router\n\n**Step 3:** Define or import route components.\n**Step 4:** Define your route where each one maps to a component\n**Step 5:** Create the router instance and pass the `routes` option\n**Step 6:**  Create and mount the root instance.\n\nNow you are able to navigate different pages(Home, Services) with in Vue application.\n\n\n", "code": "<script src=\"https://unpkg.com/vue/dist/vue.js\"></script>\n<script src=\"https://unpkg.com/vue-router/dist/vue-router.js\"></script>\n\n<div id=\"app\">\n<h1>Welcome to Vue routing app!</h1>\n<p>\n<!-- use router-link component for navigation using `to` prop. It rendered as an `<a>` tag -->\n<router-link to=\"/home\">Home</router-link>\n<router-link to=\"/services\">Services</router-link>\n</p>\n<!-- route outlet in which component matched by the route will render here -->\n<router-view></router-view>\n</div>\nimport Vue from 'vue';\nimport VueRouter from 'vue-router';\n\nVue.use(VueRouter)\nconst Home = ( template: '<div>Home</div>' )\nconst Services = ( template: '<div>Services</div>' )\nconst routes = [\n( path: '/home', component: Home ),\n( path: '/services', component: Services )\n]\nconst router = new VueRouter((\nroutes // short for `routes: routes`\n))\nconst app = new Vue((\nrouter\n)).$mount('#app')\n"}, {"question": "43.   What is dynamic route matching?", "answer": "Sometimes it may be required to map routes to the same component based on a pattern.\n\nLet's take a user component with the mapped URLs like `/user/john/post/123` and `/user/jack/post/235` using dynamic segments,\n\n\n", "code": "const User = (\ntemplate: '<div>User (( $route.params.name )), PostId: (( route.params.postid ))</div>'\n)\n\nconst router = new VueRouter((\nroutes: [\n// dynamic segments start with a colon\n( path: '/user/:name/post/:postid', component: User )\n]\n))\n"}, {"question": "44.   How to make router param changes as reactive?", "answer": "When you navigate from one URL to other(mapped with a single component) using routes with params then the same component instance will be reused. Even though it is more efficient than destroying the old instance and then creating a new one, the lifecycle hooks of the component will not be called.\n\nThis problem can be solved using either of the below approaches,\n\n1. **Watch the $route object:**\n2. **Use beforeRouteUpdate navigation guard:** This is only available since 2.2 version.\nNote that the beforeRouteEnter guard does NOT have access to `this`. Instead you can pass a callback to `next` to access the vm instance.\n\n\n", "code": "const User = (\ntemplate: '<div>User (( $route.params.name )) </div>',\nwatch: (\n'$route' (to, from) (\n// react to route changes...\n)\n)\n)\nconst User = (\ntemplate: '<div>User (( $route.params.name )) </div>',\nbeforeRouteUpdate (to, from, next) (\n// react to route changes and then call next()\n)\n)\n"}, {"question": "45.   What is route matching priority?", "answer": "Sometimes the URL might be matched by multiple routes and the confusion of which route need to be mapped is resolved by route matching priority. The priority is based on order of routes configuration. i.e, The route which declared first has higher priority.\n\n\n", "code": "const router = new VueRouter((\nroutes: [\n// dynamic segments start with a colon\n( path: '/user/:name', component: User ) // This route gets higher priority\n( path: '/user/:name', component: Admin )\n( path: '/user/:name', component: Customer )\n]\n))\n"}, {"question": "46.   What are nested routes?", "answer": "Generally, the app is composed of nested components which are nested multiple levels deep. The segments of a URL corresponds to a certain structure of these nested components. To render components into the nested outlet, you need to use the `children` option in `VueRouter` constructor config.\n\nLet's take a user app composed of profile and posts nested components with respective routes. You can also define a default route configuration when there is no matching nested route.\n\n\n", "code": "const router = new VueRouter((\nroutes: [\n( path: '/user/:id', component: User,\nchildren: [\n(\n// UserProfile will be rendered inside User's <router-view> when /user/:id/profile is matched\npath: 'profile',\ncomponent: UserProfile\n),\n(\n// UserPosts will be rendered inside User's <router-view> when /user/:id/posts is matched\npath: 'posts',\ncomponent: UserPosts\n),\n// UserHome will be rendered inside User's <router-view> when /user/:id is matched\n(  path: '',\ncomponent: UserHome ),\n]\n)\n]\n))\n"}, {"question": "47.   What are single file components?", "answer": "Single File Components are an easy concept to understand. Earlier you might heard about all three parts(HTML, JavaScript and CSS) of your application kept in different components. But Single File Components encapsulate the structure, styling and behaviour into one file. In the beginning, it seems strange to have all three parts in one file, but it actually makes a lot more sense.\n\nLet's take an example of Singile File Components\n\n\n", "code": "<template>\n<div>\n<h1>Welcome (( name ))!</h1>\n</div>\n</template>\n\n<script>\nmodule.exports = (\ndata: function() (\nreturn (\nname: 'John'\n)\n)\n)\n</script>\n\n<style scoped>\nh1 (\ncolor: #34c779;\npadding: 3px;\n)\n</style>\n"}, {"question": "48.   Is Single File Components violating separation of concerns?", "answer": "As for the latest modern UI development, separation of concerns is not equal to separation of file types. So it is preferred to divide codebase layers into loosely-coupled components and compose them instead of dividing the codebase into three huge layers that interweave with one another. This way makes Single File Components more cohesive and maintainable by combining template, logic and styles together inside a component.\nYou can also still maintain javascript and CSS files separately with hot-reloading and pre-compilation features.\n\nFor example,\n\n\n", "code": "<template>\n<div>This section will be pre-compiled and hot reloaded</div>\n</template>\n<script src=\"./my-component.js\"></script>\n<style src=\"./my-component.css\"></style>\n"}, {"question": "49.   What are the problems solved by Single File Components?", "answer": "The Single File Components solve the common problems occurred in a javascript driven application with a .vue extension. The list of issues are,\n1. Global definitions force unique names for every component\n2. String templates lack syntax highlighting and require ugly slashes for multiline HTML\n3. No CSS support means that while HTML and JavaScript are modularized into components, CSS is conspicuously left out\n4. No build step restricts us to HTML and ES5 JavaScript, rather than preprocessors like Pug (formerly Jade) and Babel.\n\n\n", "code": ""}, {"question": "50.   What are filters?", "answer": "Filters can be used to apply common text formatting. These Filters should be appended to the end of the JavaScript expression, denoted by the \u201cpipe\u201d symbol. You can use them in two specific cases:\n1. mustache interpolations\n2. v-bind expressions\n\nFor example, Let's define a local filter named capitalize in a component\u2019s options\nNow you can use the filter in either mustache interpolation or v-bind expression,\n\n\n", "code": "filters: (\ncapitalize: function (value) (\nif (!value) return ''\nvalue = value.toString()\nreturn value.charAt(0).toUpperCase() + value.slice(1)\n)\n)\n<!-- in mustaches -->\n(( username | capitalize ))\n\n<!-- in v-bind -->\n<div v-bind:id=\"username | capitalize\"></div>\n"}, {"question": "51.   What are the different ways to create filters?", "answer": "You can define filters in two ways,\n1. **Local filters:**\nYou can define local filters in a component\u2019s options. In this case, filter is applicable to that specific component.\n2. **Global filters:**\nYou can also define a filter globally before creating the Vue instance. In this case, filter is applicable to all the components with in the vue instance,\n\n\n", "code": "filters: (\ncapitalize: function (value) (\nif (!value) return ''\nvalue = value.toString()\nreturn value.charAt(0).toUpperCase() + value.slice(1)\n)\n)\nVue.filter('capitalize', function (value) (\nif (!value) return ''\nvalue = value.toString()\nreturn value.charAt(0).toUpperCase() + value.slice(1)\n))\n\nnew Vue((\n// ...\n))\n"}, {"question": "52.   How do you chain filters?", "answer": "You can chain filters one after the other to perform multiple manipulations on the expression. The generic structure of filter chain would be as below,\nIn the above chain stack, you can observe that message expression applied with three filters, each separated by a pipe(|) symbol. The first filter(filterA) takes the expression as a single argument and the result of the expression becomes an argument for second filter(filterB) and the chain continue for remaining filters.\n\nFor example, if you want to transform date expression with a full date format and uppercase then you can apply dateFormat and uppercase filters as below,\n\n\n", "code": "(( message | filterA | filterB | filterB ... ))\n(( birthday | dateFormat | uppercase ))\n"}, {"question": "53.   Is it possible to pass parameters for filters?", "answer": "Yes, you can pass arguments for a filter similar to a javascript function. The generic structure of filter parameters would be as follows,\nIn this case, filterA takes message expression as first argument and the explicit parameters mentioned in the filter as second and third arguments.\n\nFor example, you can find the exponential strength of a particular value\n\n\n", "code": "(( message | filterA('arg1', arg2) ))\n(( 2 | exponentialStrength(10) )) <!-- prints 2 power 10 = 1024 -->\n"}, {"question": "54.   What are plugins and their various services?", "answer": "\nPlugins provides global-level functionality to Vue application. The plugins provide various services,\n1. Add some global methods or properties. For example, vue-custom-element\n2. Add one or more global assets (directives, filters and transitions). For example, vue-touch\n3. Add some component options by global mixin. For example, vue-router\n4. Add some Vue instance methods by attaching them to Vue.prototype.\n5. A library that provides an API of its own, while at the same time injecting some combination of the above. For example, vue-router\n\n\n", "code": ""}, {"question": "55.   How to create a plugin?", "answer": "The Plugin is created by exposing an `install` method which takes Vue constructor as a first argument along with options. The structure of VueJS plugin with possible functionality would be as follows,\n\n\n", "code": "MyPlugin.install = function (Vue, options) (\n// 1. add global method or property\nVue.myGlobalMethod = function () (\n// some logic ...\n)\n\n// 2. add a global asset\nVue.directive('my-directive', (\nbind (el, binding, vnode, oldVnode) (\n// some logic ...\n)\n// ...\n))\n\n// 3. inject some component options\nVue.mixin((\ncreated: function () (\n// some logic ...\n)\n// ...\n))\n\n// 4. add an instance method\nVue.prototype.$myMethod = function (methodOptions) (\n// some logic ...\n)\n)\n"}, {"question": "56.   How to use a plugin?", "answer": "You can use plugin by passing your plugin to Vue's **use** global method. You need to apply this method before start your app by calling new Vue().\n\n\n", "code": "// calls `MyPlugin.install(Vue, ( someOption: true ))`\nVue.use(MyPlugin)\n\nnew Vue((\n//... options\n))\n"}, {"question": "57.   What are mixins?", "answer": "Mixin gives us a way to distribute reusable functionalities in Vue components. These reusable functions are merged with existing functions. A mixin object can contain any component options. Let us take an example of mixin with `created` lifecycle which can be shared across components,\n**Note:** Multiple mixins can be specified in the mixin array of the component.\n\n\n", "code": "const myMixin = (\ncreated()(\nconsole.log(\"Welcome to Mixins!\")\n)\n)\nvar app = new Vue((\nel: '#root',\nmixins: [myMixin]\n))\n"}, {"question": "58.   What are global mixins?", "answer": "Sometimes there is a need to extend the functionality of Vue or apply an option to all Vue components available in our application. In this case, mixins can be applied globally to affect all components in Vue. These mixins are called as global mixins.\n\nLet's take an example of global mixin,\nIn the above global mixin, the mixin options spread across all components with the console running during the instance creation. These are useful during test, and debugging or third party libraries. At the same time, You need to use these global mixins sparsely and carefully, because it affects every single Vue instance created, including third party components.\n\n\n", "code": "Vue.mixin((\ncreated()(\nconsole.log(\"Write global mixins\")\n)\n))\n\nnew Vue((\nel: '#app'\n))\n"}, {"question": "59.   How do you use mixins in CLI?", "answer": "Using Vue CLI, mixins can be specified anywhere in the project folder but preferably within `/src/mixins` for ease of access. Once these mixins are created in a `.js` file and exposed with the `export` keyword, they can be imported in any component with the `import` keyword and their file paths.\n\n\n", "code": ""}, {"question": "60.   What are the merging strategies in mixins?", "answer": "When a mixin and the component itself contain overlapping options, the options will be merged based on some strategies.\n1. The data objects undergo a recursive merge, with the component\u2019s data taking priority over mixins in cases of overlapping or conflicts.\n2. The Hook functions which are overlapping merged into an array so that all of them will be called. Mixin hooks will be called before the component\u2019s own hooks.\n3. The options that expect object values(such as methods, components and directives) will be merged into the same object. In this case, the component\u2019s options will take priority when there are conflicting keys in these objects.\n\n\n", "code": "var mixin = (\ndata: function () (\nreturn (\nmessage: 'Hello, this is a Mixin'\n)\n)\n)\nnew Vue((\nmixins: [mixin],\ndata: function () (\nreturn (\nmessage: 'Hello, this is a Component'\n)\n),\ncreated: function () (\nconsole.log(this.$data); // => ( message: \"Hello, this is a Component'\" )\n)\n))\nconst myMixin = (\ncreated()(\nconsole.log(\"Called from Mixin\")\n)\n)\n\nnew Vue((\nel: '#root',\nmixins: [myMixin],\ncreated()(\nconsole.log(\"Called from Component\")\n)\n))\n\n// Called from Mixin\n// Called from Component\nvar mixin = (\nmethods: (\nfirstName: function () (\nconsole.log('John')\n),\ncontact: function () (\nconsole.log('+65 99898987')\n)\n)\n)\n\nvar vm = new Vue((\nmixins: [mixin],\nmethods: (\nlastName: function () (\nconsole.log('Murray')\n),\ncontact: function () (\nconsole.log('+91 893839389')\n)\n)\n))\n\nvm.firstName() // \"John\"\nvm.lastName() // \"Murray\"\nvm.contact() // \"+91 893839389\"\n"}, {"question": "61.   What are custom options merging strategies?", "answer": "Vue uses the default strategy which overwrites the existing value while custom options are merged. But if you want a custom option merged using custom login then you need to attach a function to `Vue.config.optionMergeStrategies`\n\nFor the example, the structure of `myOptions` custom option would be as below,\nLet's take below Vuex 1.0 merging strategy as an advanced example,\n\n\n", "code": "Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) (\n// return mergedVal\n)\nconst merge = Vue.config.optionMergeStrategies.computed\nVue.config.optionMergeStrategies.vuex = function (toVal, fromVal) (\nif (!toVal) return fromVal\nif (!fromVal) return toVal\nreturn (\ngetters: merge(toVal.getters, fromVal.getters),\nstate: merge(toVal.state, fromVal.state),\nactions: merge(toVal.actions, fromVal.actions)\n)\n)\n"}, {"question": "62.   What are custom directives?", "answer": "Custom Directives are tiny commands that you can attach to DOM elements. They are prefixed with v- to let the library know you're using a special bit of markup and to keep syntax consistent. They are typically useful if you need low-level access to an HTML element to control a bit of behavior.\n\nLet's create a custom focus directive to provide focus on specific form element during page load time,\nNow you can use v-focus directive on any element as below,\n\n\n", "code": "// Register a global custom directive called `v-focus`\nVue.directive('focus', (\n// When the bound element is inserted into the DOM...\ninserted: function (el) (\n// Focus the element\nel.focus()\n)\n))\n<input v-focus>\n"}, {"question": "63.   How do you register directives locally?", "answer": "You can also register directives locally(apart from globally) using directives option in component as below,\nNow you can use v-focus directive on any element as below,\n\n\n", "code": "directives: (\nfocus: (\n// directive definition\ninserted: function (el) (\nel.focus()\n)\n)\n)\n<input v-focus>\n"}, {"question": "64.   What are the hook functions provided by directives?", "answer": "A directive object can provide several hook functions,\n1. bind: This occurs once the directive is attached to the element.\n2. inserted: This hook occurs once the element is inserted into the parent DOM.\n3. update: This hook is called when the element updates, but children haven't been updated yet.\n4. componentUpdated: This hook is called once the component and the children have been updated.\n5. unbind: This hook is called only once when the directive is removed.\n\n**Note:** There are several arguments that can be passed to the above hooks.\n\n\n", "code": ""}, {"question": "65.   What are the directive Hook Arguments?", "answer": "All the hooks have `el`, `binding`, and `vnode` as arguments. Along with that, **update** and **componentUpdated** hooks expose `oldVnode`, to differentiate between the older value passed and the newer value. Below are the arguments passed to the hooks,\n1. `el`: The element the directive is bound to and it can be used to directly manipulate the DOM.\n2. `binding`: An object containing the following properties.\n1. `name`: The name of the directive, without the `v-` prefix.\n2. `value`: The value passed to the directive. For example in `v-my-directive=\"1 + 1\"`, the value would be 2.\n3. `oldValue`: The previous value, only available in update and componentUpdated. It is available whether or not the value has changed.\n4. `expression`: The expression of the binding as a string. For example in `v-my-directive=\"1 + 1\"`, the expression would be \"1 + 1\".\n5. `arg`: The argument passed to the directive, if any. For example in v-my-directive:foo, the arg would be \"foo\".\n6. `modifiers`: An object containing modifiers, if any. For example in v-my-directive.foo.bar, the modifiers object would be `( foo: true, bar: true )`.\n3. `vnode`: The virtual node produced by Vue\u2019s compiler.\n4. `oldVnode`: The previous virtual node, only available in the update and componentUpdated hooks.\n\nThe arguments can be represented diagrammatically across the hooks as below,\n\n![custom-directives](images/custom-directives.svg)\n\n\n", "code": ""}, {"question": "66.   How do you pass multiple values to a directive?", "answer": "A directive can take any valid javascript expression. So if you want to pass multiple values then you can pass in a JavaScript object literal.\n\nLet's pass object literal to an avatar directive as below\nNow let us configure avatar directive globally,\n\n\n", "code": "<div v-avatar=\"( width: 500, height: 400, url: 'path/logo', text: 'Iron Man' )\"></div>\nVue.directive('avatar', function (el, binding) (\nconsole.log(binding.value.width) // 500\nconsole.log(binding.value.height)  // 400\nconsole.log(binding.value.url) // path/logo\nconsole.log(binding.value.text)  // \"Iron Man\"\n))\n"}, {"question": "67.   What is function shorthand in directive hooks?", "answer": "In few cases, you may want the same behavior on `bind` and `update` hooks irrespective of other hooks. In this situation you can use function shorthand,\n\n\n", "code": "Vue.directive('theme-switcher', function (el, binding) (\nel.style.backgroundColor = binding.value\n))\n"}, {"question": "68.   What is the benefit of render functions over templates?", "answer": "In VueJS, the templates are very powerful and recommended to build HTML as part of your application. However, some of the special cases like dynamic component creation based on input or slot value can be achieved through render functions. Also, these functions gives the full programmatic power of javascript eco system.\n\n\n", "code": ""}, {"question": "69.   What is a render function?", "answer": "Render function is a normal function which receives a `createElement` method as it\u2019s first argument used to create virtual nodes. Internally Vue.js' templates actually compile down to render functions at build time. Hence templates are just syntactic sugar of render functions.\n\nLet's take an example of simple Div markup and corresponding render function.\nThe HTML markup can be written in template tag as below,\nand the compiled down or explicit render function would appear as below,\n**Note:** The react components are built with render functions in JSX.\n\n\n", "code": "<template>\n<div :class=\"('is-rounded': isRounded)\">\n<p>Welcome to Vue render functions</p>\n</div>\n</template>\nrender: function (createElement) (\nreturn createElement('div', (\n'class': (\n'is-rounded': this.isRounded\n)\n), [\ncreateElement('p', 'Welcome to Vue render functions')\n]);\n)\n"}, {"question": "70.   Explain the structure of createElement with arguments?", "answer": "The createElement accepts few arguments to use all the template features.\n\nLet us see the basic structure of createElement with possible arguments,\nSee details of the date object in official [doc](https://vuejs.org/v2/guide/render-function.html#The-Data-Object-In-Depth).\n\n\n", "code": "// @returns (VNode)\ncreateElement(\n// An HTML tag name, component options, or async function resolving to one of these.\n// Type is (String | Object | Function)\n// Required.\n'div',\n\n// A data object corresponding to the attributes you would use in a template.\n// Type is (Object)\n// Optional.\n(\n// Normal HTML attributes\nattrs: (\nid: 'someId'\n),\n// Component props\nprops: (\nmyProp: 'somePropValue'\n),\n// DOM properties\ndomProps: (\ninnerHTML: 'This is some text'\n),\n// Event handlers are nested under `on`\non: (\nclick: this.clickHandler\n),\n// Similar to `v-bind:style`, accepting either a string, object, or array of objects.\nstyle: (\ncolor: 'red',\nfontSize: '14px'\n),\n// Similar to `v-bind:class`, accepting either a string, object, or array of strings and objects.\nclass: (\nclasssName1: true,\nclasssName2: false\n)\n// ....\n),\n\n// Children VNodes, built using `createElement()`, or using strings to get 'text VNodes'.\n// Type is (String | Array)\n// Optional.\n[\n'Learn about createElement arguments.',\ncreateElement('h1', 'Headline as a child virtual node'),\ncreateElement(MyComponent, (\nprops: (\nsomeProp: 'This is a prop value'\n)\n))\n]\n)\n"}, {"question": "71.   How can you write duplicate virtual nodes in a component?", "answer": "All virtual nodes(VNodes) in the component tree must be unique.i.e, You can't write duplicated nodes in a straightforward way. If you want to duplicate the same element/component many times then you should use factory function.\n\nThe below render function is invalid where you are trying to duplicate h1 element 3 times,\nYou can make duplicates with factory function,\n\n\n", "code": "render: function (createElement) (\nvar myHeadingVNode = createElement('h1', 'This is a Virtual Node')\nreturn createElement('div', [\nmyHeadingVNode, myHeadingVNode, myHeadingVNode\n])\n)\nrender: function (createElement) (\nreturn createElement('div',\nArray.apply(null, ( length: 3 )).map(function () (\nreturn createElement('h1', 'This is a Virtual Node')\n))\n)\n)\n"}, {"question": "72.   List down the template equivalents in render functions?", "answer": "VueJS provides proprietary alternatives and plain javascript usage for the template features.\n\nLet's list down them in a table for comparision,\n\n| Templates | Render function |\n|---- | --------- |\n| Conditional and looping directives: v-if and v-for  | Use JavaScript\u2019s if/else and map concepts|\n| Two-way binding: v-model  | Apply own JS logic with value binding and event binding |\n| Capture Event modifiers: .passive, .capture, .once and .capture.once or .once.capture| &, !, ~ and ~! |\n| Event and key modifiers: .stop, .prevent, .self, keys(.enter, .13) and Modifiers Keys(.ctrl, .alt, .shift, .meta) | Use javascript solutions: event.stopPropagation(), event.preventDefault(), if (event.target !== event.currentTarget) return, if (event.keyCode !== 13) return and if (!event.ctrlKey) return |\n| Slots: slot attributes | Render functions provide this.$slots and this.$scopedSlots instance properties|\n\n\n", "code": ""}, {"question": "73.   What are functional components?", "answer": "The functional components are just simple functions to create simple components just by passing a context. Every functional component follows two rules,\n1. **Stateless:** It doesn\u2019t keep any state by itself\n2. **Instanceless:** It has no instance, thus no this\n\nYou need to define `functional: true` to make it functional. Let's take an example of functional components,\n**Note:** The functional components are quite popular in React community too.\n\n\n", "code": "Vue.component('my-component', (\nfunctional: true,\n// Props are optional\nprops: (\n// ...\n),\n// To compensate for the lack of an instance,\n// we are now provided a 2nd context argument.\nrender: function (createElement, context) (\n// ...\n)\n))\n"}, {"question": "74.   What are the similarities between VueJS and ReactJS?", "answer": "Even though ReactJS and VueJS are two different frameworks there are few similarities(apart from the common goal of utilized in interface design) between them.\n1. Both frameworks are based on the **Virtual DOM** model\n2. They provide features such Component-based structure and reactivity\n3. They are intended for working with the root library, while all the additional tasks are transferred to other libraries(routing, state management etc).\n\n\n", "code": ""}, {"question": "75.   What is the difference between VueJS and ReactJS?", "answer": "Even though VueJS and ReactJS share few common features there are many difference between them.\n\nLet's list down them in a table format.\n\n| Feature | VueJS | ReactJS |\n|---- | --------- | ---- |\n| Type |  JavaScript MVVM Framework | JavaScript Library |\n| Platform  | Primarily focused on web development | Both Web and Native |\n| Learning Curve | Easy to learn the framework  | A steep learning curve and requires deep knowledge |\n| Simplicity | Vue is simpler than React | React is more complex than Vue |\n| Bootstrap Application | Vue-cli | CRA (Create React App) |\n\n\n", "code": ""}, {"question": "76.   What are the advantages of VueJS over ReactJS?", "answer": "Vue has the following advantages over React\n1. Vue is smaller and faster\n2. The convenient templates ease the process of developing\n3. It has simpler javascript syntax without learning JSX\n\n\n", "code": ""}, {"question": "77.   What are the advantages of ReactJS over VueJS?", "answer": "React has the following advantages over Vue\n1. ReactJS gives more flexibility in large apps developing\n2. Easy to test\n3. Well-suited for mobile apps creation\n4. The eco system is quite big and well matured.\n\n\n", "code": ""}, {"question": "78.   What are the differences between VueJS and Angular?", "answer": "The  the syntax of Vue and Angular is common at some points because Angular is the basis for VueJS development in the beginning.\n\nBut there are many differences between VueJS and Angular as listed,\n\n| Feature | VueJS | Angular |\n|---- | --------- | ---- |\n| Complexity | Easy to learn, simple API and design | The framework is bit huge and need some learning curve on typescript etc |\n| Binding of Data  | One-way binding | Two-way binding |\n| Learning Curve | Easy to learn the framework | A steep learning curve and requires deep knowledge |\n| Founders | Created by Former Google Employee | Powered by Google |\n| Initial Release | February 2014 | September 2016 |\n| Model | Based on Virtual DOM(Document Object Model) | Based on MVC(Model-View-Controller) |\n| Written in | JavaScript | TypeScript |\n\n\n", "code": ""}, {"question": "79.   What are dynamic components?", "answer": "The dynamic component will allow you to dynamically switch beetween multiple components without updating the route of the application and even retaining the state of the component when switching back to the initial component. It works by using `<component>` tag with `v-bind:is` attribute which accept dynamic component.\n\nLet's create a dynamic component vue instance to switch between different pages of a website,\nNow you can use the dynamic component which holds the current page,\n\nThe component will be unmounted when it is switched away but it is possible to force the inactive component alive using `<keep-alive>` component\n\n**Note:** The value of `:is` attribute can be either name of the registered component or the actual imported object itself.\n\n\n", "code": "new Vue((\nel: '#app',\ndata: (\ncurrentPage: 'home'\n),\ncomponents: (\nhome: (\ntemplate: \"<p>Home</p>\"\n),\nabout: (\ntemplate: \"<p>About</p>\"\n),\ncontact: (\ntemplate: \"<p>Contact</p>\"\n)\n)\n))\n<div id=\"app\">\n<component v-bind:is=\"currentPage\">\n<!-- component changes when currentPage changes! -->\n<!-- output: Home -->\n</component>\n</div>\n"}, {"question": "80.   What is the purpose of keep alive tag?", "answer": "Keep-alive tag is an abstract component used to preserve component state or avoid re-rendering. When you wrapped <keep-alive> tag around a dynamic component,  it caches the inactive component instances without destroying them.\n\nLet's see the example usage of it,\nWhen there are multiple conditional children, it requires that only one child is rendered at a time.\n\n**Note:** Remember that keep-alive tag doesn\u2019t render a DOM element itself, and doesn\u2019t show up in the component parent chain.\n\n\n", "code": "<!-- Inactive components will be cached! -->\n<keep-alive>\n<component v-bind:is=\"currentTabComponent\"></component>\n</keep-alive>\n<!-- multiple conditional children -->\n<keep-alive>\n<comp-a v-if=\"a > 1\"></comp-a>\n<comp-b v-else></comp-b>\n</keep-alive>\n"}, {"question": "81.   What are async components?", "answer": "In large applications, we may need to divide the app into smaller chunks and only load a component from the server when it\u2019s needed. To make this happen, Vue allows you to define your component as a factory function that asynchronously resolves your component definition. These components are known as async component.\n\nLet's see an example of async component using webpack code-splitting feature,\nVue will only trigger the factory function when the component needs to be rendered and will cache the result for future re-renders.\n\n\n", "code": "Vue.component('async-webpack-example', function (resolve, reject) (\n// Webpack automatically split your built code into bundles which are loaded over Ajax requests.\nrequire(['./my-async-component'], resolve)\n))\n"}, {"question": "82.   What is the structure of async component factory?", "answer": "Async component factory is useful to resolve the component asynchronously. The async component factory can  return an object of the below format.\n\n\n", "code": "const AsyncComponent = () => ((\n// The component to load (should be a Promise)\ncomponent: import('./MyComponent.vue'),\n// A component to use while the async component is loading\nloading: LoadingComponent,\n// A component to use if the load fails\nerror: ErrorComponent,\n// Delay before showing the loading component. Default: 200ms.\ndelay: 200,\n// The error component will be displayed if a timeout is\n// provided and exceeded. Default: Infinity.\ntimeout: 3000\n))\n"}, {"question": "83.   What are inline templates?", "answer": "If you keep an `inline-template` on a child component then it will use its inner content as a template instead of treating as reusable independent content.\n**Note:** Even though this inline-templates gives more flexibility for template authoring, it is recommended to define template using template property or <template> tag inside .vue component.\n\n\n", "code": "<my-component inline-template>\n<div>\n<h1>Inline templates</h1>\n<p>Treated as component component owne content</p>\n</div>\n</my-component>\n"}, {"question": "84.   What are X Templates?", "answer": "Apart from regular templates and inline templates, you can also define templates using a script element with the type `text/x-template` and then referencing the template by an id.\n\nLet's create a x-template for simple use case as below,\nNow you can define the template using reference id,\n\n\n", "code": "<script type=\"text/x-template\" id=\"script-template\">\n<p>Welcome to X-Template feature</p>\n</script>\nVue.component('x-template-example', (\ntemplate: '#script-template'\n))\n"}, {"question": "85.   What are recursive components?", "answer": "The Components that can recursively invoke themselves in their own template are known as recursive components.\nRecursive components are useful for displaying comments on a blog, nested menus, or basically anything where the parent and child are the same, eventhough with different content.\n\n**Note:** Remember that recursive component can lead infinite loops with `max stack size exceeded` error, so make sure recursive invocation is conditional(for example, v-if directive).\n\n\n", "code": "Vue.component('recursive-component', (\ntemplate: `<!--Invoking myself!-->\n<recursive-component></recursive-component>`\n));\n"}, {"question": "86.   How do you resolve circular dependencies between components?", "answer": "In complex applications, vue components will actually be each other\u2019s descendent and ancestor in the render tree.\n\nLet's say componentA and componentB included in their respective templates which makes circular dependency,\nThis can be solved by either registering(or wait until) the child component in `beforeCreate` hook or using webpack's asynchronous import while registering the component,\n\n**Solution1:**\n**Solution2:**\n\n\n", "code": "//ComponentA\n<div>\n<component-b >\n</div>\n//ComponentB\n<div>\n<component-a >\n</div>\nbeforeCreate: function () (\nthis.$options.components.componentB = require('./component-b.vue').default\n)\ncomponents: (\ncomponentB: () => import('./component-b.vue')\n)\n"}, {"question": "87.   How do you make sure vue application is CSP complaint?", "answer": "\nSome environments(Google Chrome Apps) prohibits the usage of `new Function()` for evaluating expressions and the full builds of vue applications depends on this feature to compile templates. Due to this reason, the full builds of VueJS application are not CSP complaint.\n\nIn this case you can use **runtime-only** builds with Webpack + vue-loader or Browserify + vueify technology stack through which templates will be precompiled into render functions. This way you can make sure VueJS applications are 100% CSP complaint.\n\n\n", "code": ""}, {"question": "88.   What is the difference between full and runtime only builds?", "answer": "\nThere are two types of builds provided by VueJS,\n\n**1. Full:** These are the builds that contain both the compiler and the runtime.\n\n**2. Runtime Only:** These builds doesn't include compiler but the code is responsible for creating Vue instances, rendering and patching virtual DOM. These are about 6KB lighter min+gzip.\n\n\n", "code": ""}, {"question": "89.   List down different builds of vuejs?", "answer": "Below are the list of different builds of VueJS based on type of build,\n\n| Type | UMD | CommonJS | ES Module (for bundlers) | ES Module (for browsers) |\n|---- | --------- | ---- | ---- | --- |\n| Full | vue.js | vue.common.js | vue.esm.js | vue.esm.browser.js |\n| Runtime only  | vue.runtime.js | vue.runtime.common.js | vue.runtime.esm.js | NA |\n| Full (production) | vue.min.js | NA | NA | vue.esm.browser.min.js |\n| Runtime-only (production) | vue.runtime.min.js | NA | NA | NA |\n\n\n", "code": ""}, {"question": "90.   How do you configure vuejs in webpack?", "answer": "You can configure vueJS in webpack using alias as below,\n\n\n\n", "code": "module.exports = (\n// ...\nresolve: (\nalias: (\n'vue$': 'vue/dist/vue.esm.js' // 'vue/dist/vue.common.js' for webpack 1\n)\n)\n)\n"}, {"question": "91.   What is the purpose of vuejs compiler?", "answer": "The compiler is  is responsible for compiling template strings into JavaScript render functions.\n\nFor example, the below code snippet shows the difference of templates which need compiler and not,\n\n\n", "code": "// this requires the compiler\nnew Vue((\ntemplate: '<div>(( message ))</div>'\n))\n\n// this does not\nnew Vue((\nrender (h) (\nreturn h('div', this.message)\n)\n))\n"}, {"question": "92.   What is Dev Tools and its purpose?", "answer": "DevTools is a browser extension allowing you to inspect and debug your Vue applications in a more user-friendly interface. You can find the below extensions for different browsers or environments,\n1. Chrome Extension\n2. Firefox Addon\n3. Standalone Electron app (works with any environment)\n\nThe DevTools plugins can be used as shown in the below snapshot,\n\n<img src=\"https://github.com/sudheerj/vuejs-interview-questions/blob/master/images/DevTools.png\" width=\"700\" height=\"500\">\n\n**Note:**\n1. If the page uses a production/minified build of Vue.js, devtools inspection is disabled by default so the Vue pane won't show up.\n2. To make it work for pages opened via `file://` protocol, you need to check \"Allow access to file URLs\" for this extension in Chrome's extension management panel.\n\n\n", "code": ""}, {"question": "93.   What is the browser support of VueJS?", "answer": "It supports all ECMAScript5 complaint browsers as mentioned in this [url](https://caniuse.com/#feat=es5). VueJS doesn't support IE8 browser and below, because it uses ECMAScript 5 features that are un-shimmable(require support from the underlying JS engine) in IE8.\n\n\n", "code": ""}, {"question": "94.   How do you use various CDNs?", "answer": "VueJS is available in jsdelivr, unpkg and cdnjs etc CDNs. Normally you can use them for prototyping or learning purposes.\n\nFor example, you can use them using jsdelivr with latest versions as below,\nYou can use it for native ES modules as below,\n\n**Note:** You can remove version number to get latest version.\n\n\n", "code": "<script src=\"https://cdn.jsdelivr.net/npm/vue@2.6.7/dist/vue.js\"></script>\n<script type=\"module\">\nimport Vue from 'https://cdn.jsdelivr.net/npm/vue@2.6.7/dist/vue.esm.browser.js'\n</script>\n"}, {"question": "95.   How do you force update?", "answer": "It is extremely rare situation of having to manually force an update despite the fact that no reactive data has changed. i.e, To force the Vue instance to re-render manually. You can do it force update using **vm.$forceUpdate()** API method.\n\n**Note:**  It does not affect all child components but only the instance itself and child components with inserted slot content.\n\n\n", "code": ""}, {"question": "96.   What is the purpose of vuejs once directive?", "answer": "If you want to render `a lot of static content` then you need to make sure it only evaluated once and then cached thereafter. In this case, you can use `v-once` directive by wrapping at the root level.\n\nThe example usage of v-once directive would be as below,\n\n**Note:** It is recommended not to overuse unless there is slow rendering due to lot of static content.\n\n\n", "code": "Vue.component('legal-terms', (\ntemplate: `\n<div v-once>\n<h1>Legal Terms</h1>\n... a lot of static content goes here...\n</div>\n`\n))\n"}, {"question": "97.   How do you access the root instance?", "answer": "The root instance(new Vue()) can be accessed with the `$root` property.\n\nLet's see the usage of root instance with an example.\n\nFirst let's create a root instance with properties and methods as below,\nNow you can access root instance data and it's methods with in subcomponents as below,\nIt is recommend using Vuex to manage state instead of using root instance as a global store.\n\n\n", "code": "// The root Vue instance\nnew Vue((\ndata: (\nage: 26\n),\ncomputed: (\nfullName: function () ( /* ... */ )\n),\nmethods: (\ninterest: function () ( /* ... */ )\n)\n))\n// Get root data\nthis.$root.age\n\n// Set root data\nthis.$root.age = 29\n\n// Access root computed properties\nthis.$root.fullName\n\n// Call root methods\nthis.$root.interest()\n"}, {"question": "98.   List out top 10 organizations using Vuejs?", "answer": "Below are the top 10 organizations using VueJS for their applications or products,\n\n1. Facebook - Used on marketing side of its Newsfeed\n2. Netflix - Used in two internal apps for building movie streaming interfaces\n3. Adobe -  Used for Portfolio, a custom website builder designed to help users showcase their creative work\n4. Xiaomi - Used for products where it sells from consumer electronics to software\n5. Alibaba - Provide their apps an excellent experience to its customers\n6. WizzAir - A budget airline WizzAir used for their customers user interface\n7. EuroNews\n8. Laracasts\n9. GitLab\n10. Laracasts\n\n\n", "code": ""}, {"question": "99.   What is the purpose of renderError?", "answer": "When the default render function encounters an error then you can use rennderError as an alternative render output. The error will be passed to renderError as the second argument.\n\nThe example usage of renderError is as below,\n\n\n", "code": "new Vue((\nrender (h) (\nthrow new Error('An error')\n),\nrenderError (h, err) (\nreturn h('div', ( style: ( color: 'red' )), err.stack)\n)\n)).$mount('#app')\n"}, {"question": "100.  How do you access parent instance?", "answer": "The $parent object refers to the **immediate outer scope**. The parent will be accessible as `this.$parent` for the child, and the child will be pushed into the parent\u2019s $children array. It establishes a parent-child relationship between the two instances(parent and child). You can access parent data and properties similar to $root.\n\n\n", "code": ""}]
