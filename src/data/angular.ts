import type { Question } from "./interfaces";

export const angularQuestions:Question[] = [{"question": "1.  What is Angular Framework?", "answer": "\nAngular is a **TypeScript-based open-source** front-end platform that makes it easy to build web, mobile and desktop applications. The major features of this framework include declarative templates, dependency injection, end to end tooling which ease application development.\n\n\n", "code": ""}, {"question": "2.  What is the difference between AngularJS and Angular?", "answer": "Angular is a completely revived component-based framework in which an application is a tree of individual components.\n\nHere are some of the major differences in tabular format:-\n\n| AngularJS | Angular |\n|---- | ---------\n| It is based on MVC architecture| This is based on Service/Controller|\n| It uses JavaScript to build the application| Uses TypeScript to build the application|\n| Based on controllers concept| This is a component based UI approach|\n| No support for mobile platforms| Fully supports mobile platforms|\n| Difficult to build SEO friendly application| Ease to build SEO friendly applications|\n\n\n", "code": ""}, {"question": "3.  What is TypeScript?", "answer": "TypeScript is a strongly typed superset of JavaScript created by Microsoft that adds optional types, classes, async/await and many other features, and compiles to plain JavaScript. Angular is written entirely in TypeScript as a primary language.\nYou can install TypeScript globally as\nLet's see a simple example of TypeScript usage:-\nThe greeter method allows only string type as argument.\n\n\n", "code": "npm install -g typescript\nfunction greeter(person: string) (\nreturn \"Hello, \" + person;\n)\n\nlet user = \"Sudheer\";\n\ndocument.body.innerHTML = greeter(user);\n"}, {"question": "4.  Write a pictorial diagram of Angular architecture?", "answer": "The main building blocks of an Angular application are shown in the diagram below:-\n![ScreenShot](images/architecture.png)\n\n\n", "code": ""}, {"question": "5.  What are the key components of Angular?", "answer": "Angular has the key components below,\n1. **Component:** These are the basic building blocks of an Angular application to control HTML views.\n2. **Modules:** An Angular module is a set of angular basic building blocks like components, directives, services etc. An application is divided into logical pieces and each piece of code is called as \"module\" which perform a single task.\n3. **Templates:** These represent the views of an Angular application.\n4. **Services:** Are used to create components which can be shared across the entire application.\n5. **Metadata:** This can be used to add more data to an Angular class.\n\n\n", "code": ""}, {"question": "6.  What are directives?", "answer": "Directives add behaviour to an existing DOM element or an existing component instance.\n\nNow this directive extends HTML element behavior with a yellow background as below\n\n", "code": "import ( Directive, ElementRef, Input ) from '@angular/core';\n\n@Directive(( selector: '[myHighlight]' ))\nexport class HighlightDirective (\nconstructor(el: ElementRef) (\nel.nativeElement.style.backgroundColor = 'yellow';\n)\n)\n<p myHighlight>Highlight me!</p>\n"}, {"question": "7.  What are components?", "answer": "Components are the most basic UI building block of an Angular app, which form a tree of Angular components. These components are a subset of directives. Unlike directives, components always have a template, and only one component can be instantiated per element in a template.\nLet's see a simple example of Angular component\n\n\n", "code": "import ( Component ) from '@angular/core';\n\n@Component ((\nselector: 'my-app',\ntemplate: ` <div>\n<h1>((title))</h1>\n<div>Learn Angular6 with examples</div>\n</div> `,\n))\n\nexport class AppComponent (\ntitle: string = 'Welcome to Angular world';\n)\n"}, {"question": "8.  What are the differences between Component and Directive?", "answer": "In a short note, A component(@component) is a directive-with-a-template.\n\nSome of the major differences are mentioned in a tabular form\n\n| Component | Directive |\n|---- | ---------\n| To register a component we use @Component meta-data annotation  | To register a directive we use @Directive meta-data annotation |\n| Components are typically used to create UI widgets| Directives are used to add behavior to an existing DOM element |\n| Component is used to break down the application into smaller components| Directive is used to design re-usable components|\n| Only one component can be present per DOM element | Many directives can be used per DOM element |\n| @View decorator or templateurl/template are mandatory | Directive doesn't use View|\n\n\n", "code": ""}, {"question": "9.  What is a template?", "answer": "A template is a HTML view where you can display data by binding controls to properties of an Angular component. You can store your component's template in one of two places. You can define it inline using the template property, or you can define the template in a separate HTML file and link to it in the component metadata using the @Component decorator's templateUrl property.\n\n**Using inline template with template syntax,**\n**Using separate template file such as app.component.html**\n\n\n", "code": "import ( Component ) from '@angular/core';\n\n@Component ((\nselector: 'my-app',\ntemplate: '\n<div>\n<h1>((title))</h1>\n<div>Learn Angular</div>\n</div>\n'\n))\n\nexport class AppComponent (\ntitle: string = 'Hello World';\n)\nimport ( Component ) from '@angular/core';\n\n@Component ((\nselector: 'my-app',\ntemplateUrl: 'app/app.component.html'\n))\n\nexport class AppComponent (\ntitle: string = 'Hello World';\n)\n"}, {"question": "10.  What is a module?", "answer": "\nModules are logical boundaries in your application and the application is divided into separate modules to separate the functionality of your application.\nLets take an example of **app.module.ts** root module declared with **@NgModule** decorator as below,\nThe NgModule decorator has five important (among all) options:\n1. The imports option is used to import other dependent modules. The BrowserModule is required by default for any web based angular application.\n2. The declarations option is used to define components in the respective module.\n3. The bootstrap option tells Angular which Component to bootstrap in the application.\n4. The providers option is used to configure a set of injectable objects that are available in the injector of this module.\n5. The entryComponents option is a set of components dynamically loaded into the view.\n\n\n", "code": "import ( NgModule )      from '@angular/core';\nimport ( BrowserModule ) from '@angular/platform-browser';\nimport ( AppComponent )  from './app.component';\n\n@NgModule ((\nimports:      [ BrowserModule ],\ndeclarations: [ AppComponent ],\nbootstrap:    [ AppComponent ],\nproviders: []\n))\nexport class AppModule ( )\n"}, {"question": "11.  What are lifecycle hooks available?", "answer": "Angular application goes through an entire set of processes or has a lifecycle right from its initiation to the end of the application.\nThe representation of lifecycle in pictorial representation as follows,\n\n![ScreenShot](images/lifecycle.png)\n\nThe description of each lifecycle method is as below,\n1. **ngOnChanges:** When the value of a data bound property changes, then this method is called.\n2. **ngOnInit:** This is called whenever the initialization of the directive/component after Angular first displays the data-bound properties happens.\n3. **ngDoCheck:** This is for the detection and to act on changes that Angular can't or won't detect on its own.\n4. **ngAfterContentInit:** This is called in response after Angular projects external content into the component's view.\n5. **ngAfterContentChecked:** This is called in response after Angular checks the content projected into the component.\n6. **ngAfterViewInit:** This is called in response after Angular initializes the component's views and child views.\n7. **ngAfterViewChecked:** This is called in response after Angular checks the component's views and child views.\n8. **ngOnDestroy:** This is the cleanup phase just before Angular destroys the directive/component.\n\n\n", "code": ""}, {"question": "12.  What is a data binding?", "answer": "Data binding is a core concept in Angular and allows to define communication between a component and the DOM, making it very easy to define interactive applications without worrying about pushing and pulling data. There are four forms of data binding(divided as 3 categories) which differ in the way the data is flowing.\n1. **From the Component to the DOM:**\n\n**Interpolation:** (( value )): Adds the value of a property from the component\n**Property binding:** [property]=\u201dvalue\u201d: The value is passed from the component to the specified property or simple HTML attribute\n2. **From the DOM to the Component:**\n**Event binding: (event)=\u201dfunction\u201d:** When a specific DOM event happens (eg.: click, change, keyup), call the specified method in the component\n3. **Two-way binding:**\n**Two-way data binding:** [(ngModel)]=\u201dvalue\u201d: Two-way data binding allows to have the data flow both ways. For example, in the below code snippet, both the email DOM input and component email property are in sync\n\n\n", "code": "<li>Name: (( user.name ))</li>\n<li>Address: (( user.address ))</li>\n<input type=\"email\" [value]=\"user.email\">\n<button (click)=\"logout()\"></button>\n<input type=\"email\" [(ngModel)]=\"user.email\">\n"}, {"question": "13.  What is metadata?", "answer": "Metadata is used to decorate a class so that it can configure the expected behavior of the class. The metadata is represented by decorators\n1. **Class decorators**, e.g. @Component and @NgModule\n2. **Property decorators** Used for properties inside classes, e.g. @Input and @Output\n3. **Method decorators** Used for methods inside classes, e.g. @HostListener\n4. **Parameter decorators** Used for parameters inside class constructors, e.g. @Inject, @Optional\n\n", "code": "import ( NgModule, Component ) from '@angular/core';\n\n@Component((\nselector: 'my-component',\ntemplate: '<div>Class decorator</div>',\n))\nexport class MyComponent (\nconstructor() (\nconsole.log('Hey I am a component!');\n)\n)\n\n@NgModule((\nimports: [],\ndeclarations: [],\n))\nexport class MyModule (\nconstructor() (\nconsole.log('Hey I am a module!');\n)\n)\nimport ( Component, Input ) from '@angular/core';\n\n@Component((\nselector: 'my-component',\ntemplate: '<div>Property decorator</div>'\n))\n\nexport class MyComponent (\n@Input()\ntitle: string;\n)\nimport ( Component, HostListener ) from '@angular/core';\n\n@Component((\nselector: 'my-component',\ntemplate: '<div>Method decorator</div>'\n))\nexport class MyComponent (\n@HostListener('click', ['$event'])\nonHostClick(event: Event) (\n// clicked, `event` available\n)\n)\nimport ( Component, Inject ) from '@angular/core';\nimport ( MyService ) from './my-service';\n\n@Component((\nselector: 'my-component',\ntemplate: '<div>Parameter decorator</div>'\n))\nexport class MyComponent (\nconstructor(@Inject(MyService) myService) (\nconsole.log(myService); // MyService\n)\n)\n"}, {"question": "14.  What is angular CLI?", "answer": "Angular CLI(**Command Line Interface**) is a command line interface to scaffold and build angular apps using nodejs style (commonJs) modules.\nYou need to install using below npm command,\nBelow are the list of few commands, which will come handy while creating angular projects\n1. **Creating New Project:** ng new <project-name>\n\n2. **Generating Components, Directives & Services:** ng generate/g <feature-name>\nThe different types of commands would be,\n* ng generate class my-new-class: add a class to your application\n* ng generate component my-new-component: add a component to your application\n* ng generate directive my-new-directive: add a directive to your application\n* ng generate enum my-new-enum: add an enum to your application\n* ng generate module my-new-module: add a module to your application\n* ng generate pipe my-new-pipe: add a pipe to your application\n* ng generate service my-new-service: add a service to your application\n\n3. **Running the Project:** ng serve\n\n\n", "code": "npm install @angular/cli@latest\n"}, {"question": "15.  What is the difference between constructor and ngOnInit?", "answer": "The **Constructor** is a default method of the class that is executed when the class is instantiated and ensures proper initialisation of fields in the class and its subclasses. Angular, or better Dependency Injector (DI), analyses the constructor parameters and when it creates a new instance by calling new MyClass() it tries to find providers that match the types of the constructor parameters, resolves them and passes them to the constructor.\n**ngOnInit** is a life cycle hook called by Angular to indicate that Angular is done creating the component.\nMostly we use ngOnInit for all the initialization/declaration and avoid stuff to work in the constructor. The constructor should only be used to initialize class members but shouldn't do actual \"work\".\nSo you should use constructor() to setup Dependency Injection and not much else. ngOnInit() is better place to \"start\" - it's where/when components' bindings are resolved.\n\n\n\n", "code": "export class App implements OnInit(\nconstructor(private myService: MyService)(\n//called first time before the ngOnInit()\n)\n\nngOnInit()(\n//called after the constructor and called  after the first ngOnChanges()\n//e.g. http call...\n)\n)\n"}, {"question": "16.  What is a service?", "answer": "A service is used when a common functionality needs to be provided to various modules. Services allow for greater separation of concerns for your application and better modularity by allowing you to extract common functionality out of components.\n\nLet's create a repoService which can be used across components,\n\nThe above service uses Http service as a dependency.\n\n\n", "code": "import ( Injectable ) from '@angular/core';\nimport ( Http ) from '@angular/http';\n\n@Injectable(( // The Injectable decorator is required for dependency injection to work\n// providedIn option registers the service with a specific NgModule\nprovidedIn: 'root',  // This declares the service with the root app (AppModule)\n))\nexport class RepoService(\nconstructor(private http: Http)(\n)\n\nfetchAll()(\nreturn this.http.get('https://api.github.com/repositories');\n)\n)\n"}, {"question": "17.  What is dependency injection in Angular?", "answer": "Dependency injection (DI), is an important application design pattern in which a class asks for dependencies from external sources rather than creating them itself. Angular comes with its own dependency injection framework for resolving dependencies( services or objects that a class needs to perform its function).So you can have your services depend on other services throughout your application.\n\n\n", "code": ""}, {"question": "18.  How is Dependency Hierarchy formed?", "answer": "Injectors in Angular have rules that can be leveraged to achieve the desired visibility of injectables in your applications. By understanding these rules, you can determine in which NgModule, Component, or Directive you should declare a provider.\n\n#### Angular has two injector hierarchies:\n![Screenshot](/images/injector%20hierarchies.png)\n\n#### Module injector\nWhen angular starts, it creates a root injector where the services will be registered, these are provided via injectable annotation. All services provided in the `ng-model` property are called providers (if those modules are not lazy-loaded).\n\nAngular recursively goes through all models which are being used in the application and creates instances for provided services in the root injector. If you provide some service in an eagerly-loaded model, the service will be added to the root injector, which makes it available across the whole application.\n\n#### Platform Module\nDuring application bootstrapping angular creates a few more injectors, above the root injector goes the platform injector, this one is created by the platform browser dynamic function inside the `main.ts` file, and it provides some platform-specific features like `DomSanitizer`.\n\n#### NullInjector()\nAt the very top, the next parent injector in the hierarchy is the `NullInjector()`.The responsibility of this injector is to throw the error if something tries to find dependencies there, unless you've used `@Optional()` because ultimately, everything ends at the `NullInjector()` and it returns an error or, in the case of `@Optional()`, `null`.\n\n![Screenshot](images/hierarchy%20diagram.png)\n\n\n#### ElementInjector\nAngular creates `ElementInjector` hierarchies implicitly for each DOM element. `ElementInjector` injector is being created for any tag that matches the angular component, or any tag on which directive is applied, and you can configure it in component and directive annotations inside the provider's property, thus, it creates its own hierarchy likewise the upper one.\n\n![Screenshot](images/element%20injector%20hieracrhy.png)\n\n\n", "code": ""}, {"question": "19.  What is the purpose of async pipe?", "answer": "The AsyncPipe subscribes to an observable or promise and returns the latest value it has emitted. When a new value is emitted, the pipe marks the component to be checked for changes.\n\nLet's take a time observable which continuously updates the view for every 2 seconds with the current time.\n\n\n", "code": "@Component((\nselector: 'async-observable-pipe',\ntemplate: `<div><code>observable|async</code>:\nTime: (( time | async ))</div>`\n))\nexport class AsyncObservablePipeComponent (\ntime: Observable<string>;\nconstructor() (\nthis.time = new Observable((observer) => (\nsetInterval(() => (\nobserver.next(new Date().toString());\n), 2000);\n));\n)\n)\n"}, {"question": "20.  What is the option to choose between inline and external template file?", "answer": "You can store your component's template in one of two places. You can define it inline using the **template** property, or you can define the template in a separate HTML file and link to it in the component metadata using the **@Component** decorator's **templateUrl** property.\n\nThe choice between inline and separate HTML is a matter of taste, circumstances, and organization policy. But normally we use inline template for small portion of code and external template file for bigger views. By default, the Angular CLI generates components with a template file. But you can override that with the below command,\n\n\n", "code": "ng generate component hero -it\n"}, {"question": "21.  What is the purpose of `*ngFor` directive?", "answer": "We use Angular `*ngFor` directive in the template to display each item in the list. For example, here we can iterate over a list of users:\nThe user variable in the `*ngFor` double-quoted instruction is a **template input variable**.\n\n\n", "code": "<li *ngFor=\"let user of users\">\n(( user ))\n</li>\n"}, {"question": "22.  What is the purpose of `*ngIf` directive?", "answer": "Sometimes an app needs to display a view or a portion of a view only under specific circumstances. The Angular `*ngIf` directive inserts or removes an element based on a truthy/falsy condition. Let's take an example to display a message if the user age is more than 18:\n**Note:** Angular isn't showing and hiding the message. It is adding and removing the paragraph element from the DOM. That improves performance, especially in the larger projects with many data bindings.\n\n\n", "code": "<p *ngIf=\"user.age > 18\">You are not eligible for student pass!</p>\n"}, {"question": "23.  What happens if you use script tag inside template?", "answer": "\nAngular recognizes the value as unsafe and automatically sanitizes it, which removes the `script` tag but keeps safe content such as the text content of the `script` tag. This way it eliminates the risk of script injection attacks. If you still use it then it will be ignored and a warning appears in the browser console.\n\nLet's take an example of innerHtml property binding which causes XSS vulnerability,\n\n\n", "code": "export class InnerHtmlBindingComponent (\n// For example, a user/attacker-controlled value from a URL.\nhtmlSnippet = 'Template <script>alert(\"0wned\")</script> <b>Syntax</b>';\n)\n"}, {"question": "24.  What is interpolation?", "answer": "\nInterpolation is a special syntax that Angular converts into property binding. It\u2019s a convenient alternative to property binding. It is represented by double curly braces((())). The text between the braces is often the name of a component property. Angular replaces that name with the string value of the corresponding component property.\n\nLet's take an example,\nIn the example above, Angular evaluates the title and url properties and fills in the blanks, first displaying a bold application title and then a URL.\n\n\n", "code": "<h3>\n((title))\n<img src=\"((url))\" style=\"height:30px\">\n</h3>\n"}, {"question": "25.  What are template expressions?", "answer": "A template expression produces a value similar to any Javascript expression. Angular executes the expression and assigns it to a property of a binding target; the target might be an HTML element, a component, or a directive. In the property binding, a template expression appears in quotes to the right of the = symbol as in `[property]=\"expression\"`.\nIn interpolation syntax, the template expression is surrounded by double curly braces. For example, in the below interpolation, the template expression is `((username))`,\n\n\nThe below javascript expressions are prohibited in template expression\n1. assignments (=, +=, -=, ...)\n2. new\n3. chaining expressions with ; or ,\n4. increment and decrement operators (++ and --)\n----------------------------------\n\n\n", "code": "<h3>((username)), welcome to Angular</h3>\n"}, {"question": "26.  What are template statements?", "answer": "A template statement responds to an event raised by a binding target such as an element, component, or directive. The template statements appear in quotes to the right of the = symbol like `(event)=\"statement\"`.\n\nLet's take an example of button click event's statement\n\nIn the above expression, editProfile is a template statement. The below JavaScript syntax expressions are not allowed.\n1. new\n2. increment and decrement operators, ++ and --\n3. operator assignment, such as += and -=\n4. the bitwise operators | and &\n5. the template expression operators\n--------------------------------------\n\n\n", "code": "<button (click)=\"editProfile()\">Edit Profile</button>\n"}, {"question": "27.  How do you categorize data binding types?", "answer": "\nBinding types can be grouped into three categories distinguished by the direction of data flow. They are listed as below,\n1. From the source-to-view\n2. From view-to-source\n3. View-to-source-to-view\n\nThe possible binding syntax can be tabularized as below,\n\n| Data direction | Syntax | Type |\n|---- | --------- | ---- |\n| From the source-to-view(One-way)  | 1. ((expression)) 2. [target]=\"expression\" 3. bind-target=\"expression\" | Interpolation, Property, Attribute, Class, Style|\n| From view-to-source(One-way) | 1. (target)=\"statement\" 2. on-target=\"statement\" | Event |\n| View-to-source-to-view(Two-way)| 1. [(target)]=\"expression\" 2. bindon-target=\"expression\"| Two-way |\n\n\n", "code": ""}, {"question": "28.  What are pipes?", "answer": "Pipes are simple functions that use [template expressions](#what-are-template-expressions) to accept data as input and transform it into a desired output. For example, let us take a pipe to transform a component's birthday property into a human-friendly date using **date** pipe.\n\n\n\n", "code": "import ( Component ) from '@angular/core';\n\n@Component((\nselector: 'app-birthday',\ntemplate: `<p>Birthday is (( birthday | date ))</p>`\n))\nexport class BirthdayComponent (\nbirthday = new Date(1987, 6, 18); // June 18, 1987\n)\n"}, {"question": "29.  What is a parameterized pipe?", "answer": "A pipe can accept any number of optional parameters to fine-tune its output. The parameterized pipe can be created by declaring the pipe name with a colon ( : ) and then the parameter value. If the pipe accepts multiple parameters, separate the values with colons. Let's take a birthday example with a particular format(dd/MM/yyyy):\n\n**Note:** The parameter value can be any valid template expression, such as a string literal or a component property.\n\n\n", "code": "import ( Component ) from '@angular/core';\n\n@Component((\nselector: 'app-birthday',\ntemplate: `<p>Birthday is (( birthday | date:'dd/MM/yyyy'))</p>` // 18/06/1987\n))\nexport class BirthdayComponent (\nbirthday = new Date(1987, 6, 18);\n)\n"}, {"question": "30.  How do you chain pipes?", "answer": "You can chain pipes together in potentially useful combinations as per the needs. Let's take a birthday property which uses date pipe(along with parameter) and uppercase pipes as below\n\n\n\n", "code": "import ( Component ) from '@angular/core';\n\n@Component((\nselector: 'app-birthday',\ntemplate: `<p>Birthday is ((  birthday | date:'fullDate' | uppercase)) </p>` // THURSDAY, JUNE 18, 1987\n))\nexport class BirthdayComponent (\nbirthday = new Date(1987, 6, 18);\n)\n\n"}, {"question": "31.  What is a custom pipe?", "answer": "Apart from built-in pipes, you can write your own custom pipe with the below key characteristics:\n1. A pipe is a class decorated with pipe metadata `@Pipe` decorator, which you import from the core Angular library\nFor example,\n2. The pipe class implements the **PipeTransform** interface's transform method that accepts an input value followed by optional parameters and returns the transformed value.\nThe structure of `PipeTransform` would be as below,\n3. The `@Pipe` decorator allows you to define the pipe name that you'll use within template expressions. It must be a valid JavaScript identifier.\n\n\n", "code": "@Pipe((name: 'myCustomPipe'))\ninterface PipeTransform (\ntransform(value: any, ...args: any[]): any\n)\ntemplate: `((someInputValue | myCustomPipe: someOtherValue))`\n"}, {"question": "32.  Give an example of custom pipe?", "answer": "You can create custom reusable pipes for the transformation of existing value. For example, let us create a custom pipe for finding file size based on an extension,\nNow you can use the above pipe in template expression as below,\n\n\n", "code": "import ( Pipe, PipeTransform ) from '@angular/core';\n\n@Pipe((name: 'customFileSizePipe'))\nexport class FileSizePipe implements PipeTransform (\ntransform(size: number, extension: string = 'MB'): string (\nreturn (size / (1024 * 1024)).toFixed(2) + extension;\n)\n)\ntemplate: `\n<h2>Find the size of a file</h2>\n<p>Size: ((288966 | customFileSizePipe: 'GB'))</p>\n`\n"}, {"question": "33.  What is the difference between pure and impure pipe?", "answer": "A pure pipe is only called when Angular detects a change in the value or the parameters passed to a pipe. For example, any changes to a primitive input value (String, Number, Boolean, Symbol) or a changed object reference (Date, Array, Function, Object). An impure pipe is called for every change detection cycle no matter whether the value or parameters changes. i.e, An impure pipe is called often, as often as every keystroke or mouse-move.\n\n\n", "code": ""}, {"question": "34.  What is a bootstrapping module?", "answer": "Every application has at least one Angular module, the root module that you bootstrap to launch the application is called as bootstrapping module. It is commonly known as `AppModule`. The default structure of `AppModule` generated by AngularCLI would be as follows:\n\n\n\n", "code": "import ( BrowserModule ) from '@angular/platform-browser';\nimport ( NgModule ) from '@angular/core';\nimport ( FormsModule ) from '@angular/forms';\nimport ( HttpClientModule ) from '@angular/common/http';\n\nimport ( AppComponent ) from './app.component';\n\n/* the AppModule class with the @NgModule decorator */\n@NgModule((\ndeclarations: [\nAppComponent\n],\nimports: [\nBrowserModule,\nFormsModule,\nHttpClientModule\n],\nproviders: [],\nbootstrap: [AppComponent]\n))\nexport class AppModule ( )\n"}, {"question": "35.  What are observables?", "answer": "Observables are declarative which provide support for passing messages between publishers and subscribers in your application. They are mainly used for event handling, asynchronous programming, and handling multiple values. In this case, you define a function for publishing values, but it is not executed until a consumer subscribes to it. The subscribed consumer then receives notifications until the function completes, or until they unsubscribe.\n\n\n", "code": ""}, {"question": "36.  What is HttpClient and its benefits?", "answer": "Most of the Front-end applications communicate with backend services over `HTTP` protocol using either `XMLHttpRequest` interface or the `fetch()` API. Angular provides a simplified client HTTP API known as `HttpClient` which is based on top of `XMLHttpRequest` interface. This client is avaialble from `@angular/common/http` package.\nYou can import in your root module as below:\n\n\nThe major advantages of HttpClient can be listed as below,\n1. Contains testability features\n2. Provides typed request and response objects\n3. Intercept request and response\n4. Supports Observalbe APIs\n5. Supports streamlined error handling\n\n\n", "code": "import ( HttpClientModule ) from '@angular/common/http';\n"}, {"question": "37.  Explain on how to use `HttpClient` with an example?", "answer": "Below are the steps need to be followed for the usage of `HttpClient`.\n1. Import `HttpClient` into root module:\n2. Inject the `HttpClient` into the application:\nLet's create a userProfileService(`userprofile.service.ts`) as an example. It also defines get method of `HttpClient`:\n3. Create a component for subscribing service:\nLet's create a component called UserProfileComponent(`userprofile.component.ts`), which injects `UserProfileService` and invokes the service method:\nSince the above service method returns an Observable which needs to be subscribed in the component.\n\n\n", "code": "import ( HttpClientModule ) from '@angular/common/http';\n@NgModule((\nimports: [\nBrowserModule,\n// import HttpClientModule after BrowserModule.\nHttpClientModule,\n],\n......\n))\nexport class AppModule ()\nimport ( Injectable ) from '@angular/core';\nimport ( HttpClient ) from '@angular/common/http';\n\nconst userProfileUrl: string = 'assets/data/profile.json';\n\n@Injectable()\nexport class UserProfileService (\nconstructor(private http: HttpClient) ( )\n\ngetUserProfile() (\nreturn this.http.get(this.userProfileUrl);\n)\n)\nfetchUserProfile() (\nthis.userProfileService.getUserProfile()\n.subscribe((data: User) => this.user = (\nid: data['userId'],\nname: data['firstName'],\ncity:  data['city']\n));\n)\n"}, {"question": "38.  How can you read full response?", "answer": "The response body doesn't or may not return full response data because sometimes servers also return special headers or status code, which are important for the application workflow. In order to get the full response, you should use `observe` option from `HttpClient`:\n\nNow `HttpClient.get()` method returns an Observable of typed `HttpResponse` rather than just the `JSON` data.\n\n\n", "code": "getUserResponse(): Observable<HttpResponse<User>> (\nreturn this.http.get<User>(\nthis.userUrl, ( observe: 'response' ));\n)\n"}, {"question": "39.  How do you perform Error handling?", "answer": "If the request fails on the server or fails to reach the server due to network issues, then `HttpClient` will return an error object instead of a successful reponse. In this case, you need to handle in the component by passing `error` object as a second callback to `subscribe()` method.\n\nLet's see how it can be handled in the component with an example,\nIt is always a good idea to give the user some meaningful feedback instead of displaying the raw error object returned from `HttpClient`.\n\n\n", "code": "fetchUser() (\nthis.userService.getProfile()\n.subscribe(\n(data: User) => this.userProfile = ( ...data ), // success path\nerror => this.error = error // error path\n);\n)\n"}, {"question": "40.  What is RxJS?", "answer": "RxJS is a library for composing asynchronous and callback-based code in a functional, reactive style using Observables. Many APIs such as  HttpClient produce and consume RxJS Observables and also uses operators for processing observables.\n\nFor example, you can import observables and operators for using HttpClient as below,\n\n\n", "code": "import ( Observable, throwError ) from 'rxjs';\nimport ( catchError, retry ) from 'rxjs/operators';\n"}, {"question": "41.  What is subscribing?", "answer": "An Observable instance begins publishing values only when someone subscribes to it. So you need to subscribe by calling the `subscribe()` method of the instance, passing an observer object to receive the notifications.\n\nLet's take an example of creating and subscribing to a simple observable, with an observer that logs the received message to the console.\n\n\n", "code": "// Creates an observable sequence of 5 integers, starting from 1\nconst source = range(1, 5);\n\n// Create observer object\nconst myObserver = (\nnext: x => console.log('Observer got a next value: ' + x),\nerror: err => console.error('Observer got an error: ' + err),\ncomplete: () => console.log('Observer got a complete notification'),\n);\n\n// Execute with the observer object and Prints out each item\nsource.subscribe(myObserver);\n// => Observer got a next value: 1\n// => Observer got a next value: 2\n// => Observer got a next value: 3\n// => Observer got a next value: 4\n// => Observer got a next value: 5\n// => Observer got a complete notification\n"}, {"question": "42.  What is an observable?", "answer": "An Observable is a unique Object similar to a Promise that can help manage async code. Observables are not part of the JavaScript language so we need to rely on a popular Observable library called RxJS.\nThe observables are created using new keyword.\n\nLet see the simple example of observable,\n\n\n", "code": "import ( Observable ) from 'rxjs';\n\nconst observable = new Observable(observer => (\nsetTimeout(() => (\nobserver.next('Hello from a Observable!');\n), 2000);\n));\n"}, {"question": "43.  What is an observer?", "answer": "Observer is an interface for a consumer of push-based notifications delivered by an Observable. It has below structure,\n\nA handler that implements the Observer interface for receiving observable notifications will be passed as a parameter for observable as below,\n\n**Note:** If you don't supply a handler for a notification type, the observer ignores notifications of that type.\n\n\n", "code": "interface Observer<T> (\nclosed?: boolean;\nnext: (value: T) => void;\nerror: (err: any) => void;\ncomplete: () => void;\n)\nmyObservable.subscribe(myObserver);\n"}, {"question": "44.  What is the difference between promise and observable?", "answer": "Below are the list of differences between promise and observable:\n\n| Observable | Promise |\n|---- | --------- |\n| Declarative: Computation does not start until subscription, so they can run whenever you need the result | Executes immediately on creation|\n| Provides multiple values over time | Provides only one |\n| Subscribe method is used for error handling that facilitates centralized and predictable error handling | Push errors to the child promises |\n| Provides chaining and subscription to handle complex applications | Uses only `.then()` clause |\n\n\n", "code": ""}, {"question": "45.  What is multicasting?", "answer": "Multi-casting is the practice of broadcasting to a list of multiple subscribers in a single execution.\n\nLet's demonstrate the multi-casting feature:\n\n\n", "code": "var source = Rx.Observable.from([1, 2, 3]);\nvar subject = new Rx.Subject();\nvar multicasted = source.multicast(subject);\n\n// These are, under the hood, `subject.subscribe((...))`:\nmulticasted.subscribe((\nnext: (v) => console.log('observerA: ' + v)\n));\nmulticasted.subscribe((\nnext: (v) => console.log('observerB: ' + v)\n));\n\n// This is, under the hood, `s\n"}, {"question": "46.  How do you perform error handling in observables?", "answer": "You can handle errors by specifying an **error callback** on the observer instead of relying on `try`/`catch`, which are ineffective in asynchronous environment.\n\nFor example, you can define error callback as below,\n\n\n", "code": "myObservable.subscribe((\nnext(num) ( console.log('Next num: ' + num)),\nerror(err) ( console.log('Received an errror: ' + err))\n));\n"}, {"question": "47.  What is the shorthand notation for subscribe method?", "answer": "The `subscribe()` method can accept callback function definitions in line, for `next`, `error`, and `complete` handlers. It is known as shorthand notation or Subscribe method with positional arguments.\n\nFor example, you can define subscribe method as below,\n\n\n", "code": "myObservable.subscribe(\nx => console.log('Observer got a next value: ' + x),\nerr => console.error('Observer got an error: ' + err),\n() => console.log('Observer got a complete notification')\n);\n"}, {"question": "48.  What are the utility functions provided by RxJS?", "answer": "The RxJS library also provides below utility functions for creating and working with observables.\n\n1. Converting existing code for async operations into observables\n2. Iterating through the values in a stream\n3. Mapping values to different types\n4. Filtering streams\n5. Composing multiple streams\n\n\n", "code": ""}, {"question": "49.  What are observable creation functions?", "answer": "RxJS provides creation functions for the process of creating observables from promises, events, timers and Ajax requests. Let us explain each of them with an example:\n1. Create an observable from a promise\n2. Create an observable that creates an AJAX request\n3. Create an observable from a counter\n4. Create an observable from an event\n\n\n", "code": "import ( from ) from 'rxjs'; // from function\nconst data = from(fetch('/api/endpoint')); //Created from Promise\ndata.subscribe((\nnext(response) ( console.log(response); ),\nerror(err) ( console.error('Error: ' + err); ),\ncomplete() ( console.log('Completed'); )\n));\nimport ( ajax ) from 'rxjs/ajax'; // ajax function\nconst apiData = ajax('/api/data'); // Created from AJAX request\n// Subscribe to create the request\napiData.subscribe(res => console.log(res.status, res.response));\nimport ( interval ) from 'rxjs'; // interval function\nconst secondsCounter = interval(1000); // Created from Counter value\nsecondsCounter.subscribe(n =>\nconsole.log(`Counter value: $(n)`));\nimport ( fromEvent ) from 'rxjs';\nconst el = document.getElementById('custom-element');\nconst mouseMoves = fromEvent(el, 'mousemove');\nconst subscription = mouseMoves.subscribe((e: MouseEvent) => (\nconsole.log(`Coordnitaes of mouse pointer: $(e.clientX) * $(e.clientY)`);\n));\n"}, {"question": "50.  What will happen if you do not supply handler for the observer?", "answer": "Usually, an observer object can define any combination of `next`, `error`, and `complete` notification type handlers. If you don't supply a handler for a notification type, the observer just ignores notifications of that type.\n\n\n", "code": ""}, {"question": "51.  What are Angular elements?", "answer": "Angular elements are Angular components packaged as **custom elements** (a web standard for defining new HTML elements in a framework-agnostic way). Angular Elements host an Angular component, providing a bridge between the data and the logic defined in the component and the standard DOM APIs, thus, providing a way to use Angular components in `non-Angular environments`.\n\n\n", "code": ""}, {"question": "52.  What is the browser support of Angular Elements?", "answer": "Since Angular elements are packaged as custom elements the browser support of angular elements is same as custom elements support.\n\nThis feature is is currently supported natively in a number of browsers and pending for other browsers.\n\n| Browser | Angular Element Support |\n|---- | --------- |\n| Chrome | Natively supported|\n| Opera | Natively supported |\n| Safari| Natively supported |\n| Firefox | Natively supported from 63 version onwards. You need to enable dom.webcomponents.enabled and dom.webcomponents.customelements.enabled in older browsers |\n| Edge| Currently it is in progress|\n\n\n", "code": ""}, {"question": "53.  What are custom elements?", "answer": "Custom elements (or Web Components) are a Web Platform feature which extends HTML by allowing you to define a tag whose content is created and controlled by JavaScript code. The browser maintains a `CustomElementRegistry` of defined custom elements, which maps an instantiable JavaScript class to an HTML tag. Currently this feature is supported by Chrome, Firefox, Opera, and Safari, and available in other browsers through polyfills.\n\n\n", "code": ""}, {"question": "54.  Do I need to bootstrap custom elements?", "answer": "No, custom elements bootstrap (or start) automatically when they are added to the DOM, and are automatically destroyed when removed from the DOM. Once a custom element is added to the DOM for any page, it looks and behaves like any other HTML element, and does not require any special knowledge of Angular.\n\n\n", "code": ""}, {"question": "55.  Explain how custom elements works internally?", "answer": "Below are the steps in an order about custom elements functionality,\n1. **App registers custom element with browser:** Use the `createCustomElement()` function to convert a component into a class that can be registered with the browser as a custom element.\n2. **App adds custom element to DOM:**  Add custom element just like a built-in HTML element directly into the DOM.\n3. **Browser instantiate component based class:** Browser creates an instance of the registered class and adds it to the DOM.\n4. **Instance provides content with data binding and change detection:** The content with in template is rendered using the component and DOM data.\nThe flow chart of the custom elements functionality would be as follows,\n\n![CustomElement](images/customElement.png)\n\n\n", "code": ""}, {"question": "56.  How to transfer components to custom elements?", "answer": "Transforming components to custom elements involves **two** major steps,\n1. **Build custom element class:** Angular provides the `createCustomElement()` function for converting an Angular component (along with its dependencies) to a custom element. The conversion process implements `NgElementConstructor` interface, and creates a constructor class which is used to produce a self-bootstrapping instance of Angular component.\n2. **Register element class with browser:** It uses `customElements.define()` JS function, to register the configured constructor and its associated custom-element tag with the browser's `CustomElementRegistry`. When the browser encounters the tag for the registered element, it uses the constructor to create a custom-element instance.\n\nThe detailed structure would be as follows,\n![CreateElement](images/createElement.png)\n\n\n", "code": ""}, {"question": "57.  What are the mapping rules between Angular component and custom element?", "answer": "The Component properties and logic maps directly into HTML attributes and the browser's event system. Let us describe them in two steps,\n1. The createCustomElement() API parses the component input properties with corresponding attributes for the custom element. For example, component @Input('myInputProp') converted as custom element attribute `my-input-prop`.\n2. The Component outputs are dispatched as HTML Custom Events, with the name of the custom event matching the output name. For example, component @Output() valueChanged = new EventEmitter() converted as custom element with dispatch event as \"valueChanged\".\n\n\n", "code": ""}, {"question": "58.  How do you define typings for custom elements?", "answer": "You can use the `NgElement` and `WithProperties` types exported from @angular/elements.\n\nLet's see how it can be applied by comparing with Angular component.\n1. The simple container with input property would be as below,\n2. After applying types typescript validates input value and their types,\n\n\n", "code": "@Component(...)\nclass MyContainer (\n@Input() message: string;\n)\nconst container = document.createElement('my-container') as NgElement & WithProperties<(message: string)>;\ncontainer.message = 'Welcome to Angular elements!';\ncontainer.message = true;  // <-- ERROR: TypeScript knows this should be a string.\ncontainer.greet = 'News';  // <-- ERROR: TypeScript knows there is no `greet` property on `container`.\n"}, {"question": "59.  What are dynamic components?", "answer": "Dynamic components are the components in which the component's location in the application is not defined at build time i.e. they are not used in any angular template. Instead, the component is instantiated and placed in the application at runtime.\n\n\n", "code": ""}, {"question": "60.  What are the various kinds of directives?", "answer": "There are mainly three kinds of directives:\n1. **Components** \u2014 These are directives with a template.\n2. **Structural directives** \u2014 These directives change the DOM layout by adding and removing DOM elements.\n3. **Attribute directives** \u2014 These directives change the appearance or behavior of an element, component, or another directive.\n\n\n", "code": ""}, {"question": "61.  How do you create directives using CLI?", "answer": "You can use CLI command `ng generate directive` to create the directive class file. It creates the source file(`src/app/components/directivename.directive.ts`), the respective test file `.spec.ts` and declare the directive class file in root module.\n\n\n", "code": ""}, {"question": "62.  Give an example for attribute directives?", "answer": "Let's take simple highlighter behavior as a example directive for DOM element. You can create and apply the attribute directive using below step:\n\n1. Create HighlightDirective class with the file name `src/app/highlight.directive.ts`. In this file, we need to import **Directive** from core library to apply the metadata and **ElementRef** in the directive's constructor to inject a reference to the host DOM element ,\n2. Apply the attribute directive as an attribute to the host element(for example, <p>)\n3. Run the application to see the highlight behavior on paragraph element\n\n\n", "code": "import ( Directive, ElementRef ) from '@angular/core';\n\n@Directive((\nselector: '[appHighlight]'\n))\nexport class HighlightDirective (\nconstructor(el: ElementRef) (\nel.nativeElement.style.backgroundColor = 'red';\n)\n)\n<p appHighlight>Highlight me!</p>\nng serve\n"}, {"question": "63.  What is Angular Router?", "answer": "Angular Router is a mechanism in which navigation happens from one view to the next as users perform application tasks. It borrows the concepts or model of browser's application navigation. It enables developers to build Single Page Applications with multiple views and allow navigation between these views.\n\n\n", "code": ""}, {"question": "64.  What is the purpose of base href tag?", "answer": "The routing application should add <base> element to the index.html as the first child in the <head> tag in order to indicate how to compose navigation URLs. If app folder is the application root then you can set the href value as below\n\n\n\n", "code": "<base href=\"/\">\n"}, {"question": "65.  What are the router imports?", "answer": "The Angular Router which represents a particular component view for a given URL is not part of Angular Core. It is available in library named `@angular/router` to import required router components. For example, we import them in app module as below,\n\n\n\n", "code": "import ( RouterModule, Routes ) from '@angular/router';\n"}, {"question": "66.  What is router outlet?", "answer": "The RouterOutlet is a directive from the router library and it  acts as a placeholder that marks the spot in the template where the router should display the components for that outlet. Router outlet is used like a component,\n\n\n\n", "code": "<router-outlet></router-outlet>\n<!-- Routed components go here -->\n"}, {"question": "67.  What are router links?", "answer": "The RouterLink is a directive on the anchor tags give the router control over those elements. Since the navigation paths are fixed, you can assign string values to router-link directive as below,\n\n\n\n", "code": "<h1>Angular Router</h1>\n<nav>\n<a routerLink=\"/todosList\" >List of todos</a>\n<a routerLink=\"/completed\" >Completed todos</a>\n</nav>\n<router-outlet></router-outlet>\n"}, {"question": "68.  What are active router links?", "answer": "RouterLinkActive is a directive that toggles css classes for active RouterLink bindings based on the current RouterState. i.e, The Router will add CSS classes when this link is active and remove when the link is inactive. For example, you can add them to RouterLinks as below.\n\n\n\n", "code": "<h1>Angular Router</h1>\n<nav>\n<a routerLink=\"/todosList\" routerLinkActive=\"active\">List of todos</a>\n<a routerLink=\"/completed\" routerLinkActive=\"active\">Completed todos</a>\n</nav>\n<router-outlet></router-outlet>\n"}, {"question": "69.  What is router state?", "answer": "RouterState is a tree of activated routes. Every node in this tree knows about the \"consumed\" URL segments, the extracted parameters, and the resolved data. You can access the current RouterState from anywhere in the application using the `Router service` and the `routerState` property.\n\n\n\n", "code": "@Component((templateUrl:'template.html'))\nclass MyComponent (\nconstructor(router: Router) (\nconst state: RouterState = router.routerState;\nconst root: ActivatedRoute = state.root;\nconst child = root.firstChild;\nconst id: Observable<string> = child.params.map(p => p.id);\n//...\n)\n)\n"}, {"question": "70.  What are router events?", "answer": "During each navigation, the Router emits navigation events through the Router.events property allowing you to track the lifecycle of the route.\n\nThe sequence of router events is as below,\n\n1. NavigationStart,\n2. RouteConfigLoadStart,\n3. RouteConfigLoadEnd,\n4. RoutesRecognized,\n5. GuardsCheckStart,\n6. ChildActivationStart,\n7. ActivationStart,\n8. GuardsCheckEnd,\n9. ResolveStart,\n10. ResolveEnd,\n11. ActivationEnd\n12. ChildActivationEnd\n13. NavigationEnd,\n14. NavigationCancel,\n15. NavigationError\n16. Scroll\n\n\n", "code": ""}, {"question": "71.  What is activated route?", "answer": "ActivatedRoute contains the information about a route associated with a component loaded in an outlet. It can also be used to traverse the router state tree. The ActivatedRoute will be injected as a router service to access the information. In the below example, you can access route path and parameters,\n\n\n\n", "code": "@Component((...))\nclass MyComponent (\nconstructor(route: ActivatedRoute) (\nconst id: Observable<string> = route.params.pipe(map(p => p.id));\nconst url: Observable<string> = route.url.pipe(map(segments => segments.join('')));\n// route.data includes both `data` and `resolve`\nconst user = route.data.pipe(map(d => d.user));\n)\n)\n"}, {"question": "72.  How do you define routes?", "answer": "A router must be configured with a list of route definitions. You configures the router with routes via the `RouterModule.forRoot()` method, and adds the result to the AppModule's `imports` array.\n\n\n\n", "code": "const appRoutes: Routes = [\n( path: 'todo/:id',      component: TodoDetailComponent ),\n(\npath: 'todos',\ncomponent: TodosListComponent,\ndata: ( title: 'Todos List' )\n),\n( path: '',\nredirectTo: '/todos',\npathMatch: 'full'\n),\n( path: '**', component: PageNotFoundComponent )\n];\n\n@NgModule((\nimports: [\nRouterModule.forRoot(\nappRoutes,\n( enableTracing: true ) // <-- debugging purposes only\n)\n// other imports here\n],\n...\n))\nexport class AppModule ( )\n"}, {"question": "73.  What is the purpose of Wildcard route?", "answer": "If the URL doesn't match any predefined routes then it causes the router to throw an error and crash the app. In this case, you can use wildcard route. A wildcard route has a path consisting of two asterisks to match every URL.\n\nFor example, you can define PageNotFoundComponent for wildcard route as below\n\n\n", "code": "( path: '**', component: PageNotFoundComponent )\n"}, {"question": "74.  Do I need a Routing Module always?", "answer": "No, the Routing Module is a design choice. You can skip routing Module (for example, AppRoutingModule) when the configuration is simple and merge the routing configuration directly into the companion module (for example, AppModule). But it is recommended when the configuration is complex and includes specialized guard and resolver services.\n\n\n", "code": ""}, {"question": "75.  What is Angular Universal?", "answer": "Angular Universal is a server-side rendering module for Angular applications in various scenarios. This is a community driven project and available under @angular/platform-server package. Recently Angular Universal is integrated with Angular CLI.\n\n\n", "code": ""}, {"question": "76.  What are different types of compilation in Angular?", "answer": "Angular offers two ways to compile your application,\n1. Just-in-Time (JIT)\n2. Ahead-of-Time (AOT)\n\n\n", "code": ""}, {"question": "77.  What is JIT?", "answer": "Just-in-Time (JIT) is a type of compilation that compiles your app in the browser at runtime. JIT compilation was the default until Angular 8, now default is AOT. When you run the ng build (build only) or ng serve (build and serve locally) CLI commands, the type of compilation (JIT or AOT) depends on the value of the aot property in your build configuration specified in angular.json. By default, aot is set to true.\n\n\n", "code": ""}, {"question": "78.  What is AOT?", "answer": "Ahead-of-Time (AOT) is a type of compilation that compiles your app at build time. This is the default starting in Angular 9. When you run the ng build (build only) or ng serve (build and serve locally) CLI commands, the type of compilation (JIT or AOT) depends on the value of the aot property in your build configuration specified in angular.json. By default, aot is set to true.\n\n\n\n", "code": "ng build\nng serve\n"}, {"question": "79.  Why do we need compilation process?", "answer": "The Angular components and templates cannot be understood by the browser directly. Due to that Angular applications require a compilation process before they can run in a browser. For example, In AOT compilation, both Angular HTML and TypeScript code converted into efficient JavaScript code during the build phase before browser runs it.\n\n\n", "code": ""}, {"question": "80.  What are the advantages with AOT?", "answer": "Below are the list of AOT benefits,\n\n1. **Faster rendering:** The browser downloads a pre-compiled version of the application. So it can render the application immediately without compiling the app.\n2. **Fewer asynchronous requests:** It inlines external HTML templates and CSS style sheets within the application javascript which eliminates separate ajax requests.\n3. **Smaller Angular framework download size:** Doesn't require downloading the Angular compiler. Hence it dramatically reduces the application payload.\n4. **Detect template errors earlier:** Detects and reports template binding errors during the build step itself\n5. **Better security:** It compiles HTML templates and components into JavaScript.  So there won't be any injection attacks.\n\n\n", "code": ""}, {"question": "81.  What are the ways to control AOT compilation?", "answer": "You can control your app compilation in two ways,\n1. By providing template compiler options in the `tsconfig.json` file\n2. By configuring Angular metadata with decorators\n\n\n", "code": ""}, {"question": "82.  What are the restrictions of metadata?", "answer": "In Angular, You must write metadata with the following general constraints,\n1. Write expression syntax with in the supported range of javascript features\n2. The compiler can only reference symbols which are exported\n3. Only call the functions supported by the compiler\n4. Decorated and data-bound class members must be public.\n\n\n", "code": ""}, {"question": "83.  What are the three phases of AOT?", "answer": "The AOT compiler works in three phases,\n1. **Code Analysis:** The compiler records a representation of the source\n2. **Code generation:** It handles the interpretation as well as places restrictions on what it interprets.\n3. **Validation:** In this phase, the Angular template compiler uses the TypeScript compiler to validate the binding expressions in templates.\n\n\n", "code": ""}, {"question": "84.  Can I use arrow functions in AOT?", "answer": "No, Arrow functions or lambda functions can\u2019t be used to assign values to the decorator properties. For example, the following snippet is invalid:\n\n\nTo fix this, it has to be changed as following exported function:\n\n\nIf you still use arrow function, it generates an error node in place of the function. When the compiler later interprets this node, it reports an error to turn the arrow function into an exported function.\n**Note:** From Angular5 onwards, the compiler automatically performs this rewriting while emitting the .js file.\n\n\n", "code": "@Component((\nproviders: [(\nprovide: MyService, useFactory: () => getService()\n)]\n))\nfunction getService()(\nreturn new MyService();\n)\n\n@Component((\nproviders: [(\nprovide: MyService, useFactory: getService\n)]\n))\n"}, {"question": "85.  What is the purpose of metadata json files?", "answer": "The metadata.json file can be treated as a diagram of the overall structure of a decorator's metadata, represented as an abstract syntax tree(AST). During the analysis phase, the AOT collector scan the metadata recorded in the Angular decorators and outputs metadata information in .metadata.json files, one per .d.ts file.\n\n\n", "code": ""}, {"question": "86.  Can I use any javascript feature for expression syntax in AOT?", "answer": "No, the AOT collector understands a subset  of (or limited) JavaScript features. If an expression uses unsupported syntax, the collector writes an error node to the .metadata.json file. Later point of time, the compiler reports an error if it needs that piece of metadata to generate the application code.\n\n\n", "code": ""}, {"question": "87.  What is folding?", "answer": "The compiler can only resolve references to exported symbols in the metadata. Where as some of the non-exported members are folded while generating the code. i.e Folding is a process in which the collector evaluate an expression during collection and record the result in the .metadata.json instead of the original expression.\nFor example, the compiler couldn't refer selector reference because it is not exported\n\nWill be folded into inline selector\n\nRemember that the compiler can\u2019t fold everything. For example, spread operator on arrays, objects created using new keywords and function calls.\n\n\n", "code": "let selector = 'app-root';\n@Component((\nselector: selector\n))\n@Component((\nselector: 'app-root'\n))\n"}, {"question": "88.  What are macros?", "answer": "The AOT compiler supports macros in the form of functions or static methods that return an expression in a `single return expression`.\nFor example, let us take a below macro function,\n\n\nYou can use it inside metadata as an expression,\n\n\nThe compiler treats the macro expression as it written directly\n\n\n\n", "code": "export function wrapInArray<T>(value: T): T[] (\nreturn [value];\n)\n@NgModule((\ndeclarations: wrapInArray(TypicalComponent)\n))\nexport class TypicalModule ()\n@NgModule((\ndeclarations: [TypicalComponent]\n))\nexport class TypicalModule ()\n"}, {"question": "89.  Give an example of few metadata errors?", "answer": "Below are some of the errors encountered in metadata,\n\n1. **Expression form not supported:** Some of the language features outside of the compiler's restricted expression syntax used in angular metadata can produce this error.\nLet's see some of these examples,\n2. **Reference to a local (non-exported) symbol:** The compiler encountered a referenced to a locally defined symbol that either wasn't exported or wasn't initialized.\nLet's take example of this error,\nYou can fix this by either exporting or initializing the value,\n3. **Function calls are not supported:** The compiler does not currently support function expressions or lambda functions. For example, you cannot set a provider's useFactory to an anonymous function or arrow function as below.\nYou can fix this with exported function\n4. **Destructured variable or constant not supported:** The compiler does not support references to variables assigned by destructuring.\nFor example, you cannot write something like this:\nYou can fix this by non-destructured values\n\n\n", "code": "1. export class User ( ... )\nconst prop = typeof User; // typeof is not valid in metadata\n2. ( provide: 'token', useValue: ( [prop]: 'value' ) ); // bracket notation is not valid in metadata\n// ERROR\nlet username: string; // neither exported nor initialized\n\n@Component((\nselector: 'my-component',\ntemplate: ... ,\nproviders: [\n( provide: User, useValue: username )\n]\n))\nexport class MyComponent ()\nexport let username: string; // exported\n(or)\nlet username = 'John'; // initialized\nproviders: [\n( provide: MyStrategy, useFactory: function() ( ... ) ),\n( provide: OtherStrategy, useFactory: () => ( ... ) )\n]\nexport function myStrategy() ( ... )\nexport function otherStrategy() ( ... )\n... // metadata\nproviders: [\n( provide: MyStrategy, useFactory: myStrategy ),\n( provide: OtherStrategy, useFactory: otherStrategy ),\nimport ( user ) from './user';\n\n// destructured assignment to name and age\nconst (name, age) = user;\n... //metadata\nproviders: [\n(provide: Name, useValue: name),\n(provide: Age, useValue: age),\n]\nimport ( user ) from './user';\n... //metadata\nproviders: [\n(provide: Name, useValue: user.name),\n(provide: Age, useValue: user.age),\n]\n"}, {"question": "90.  What is metadata rewriting?", "answer": "Metadata rewriting is the process in which the compiler converts the expression initializing the fields such as useClass, useValue, useFactory, and data into an exported variable, which replaces the expression. Remember that the compiler does this rewriting during the emit of the .js file but not in definition files( .d.ts file).\n\n\n", "code": ""}, {"question": "91.  How do you provide configuration inheritance?", "answer": "Angular Compiler supports configuration inheritance through extends in the tsconfig.json on angularCompilerOptions. i.e, The configuration from the base file(for example, tsconfig.base.json) are loaded first, then overridden by those in the inheriting config file.\n\n\n\n", "code": "(\n\"extends\": \"../tsconfig.base.json\",\n\"compilerOptions\": (\n\"experimentalDecorators\": true,\n...\n),\n\"angularCompilerOptions\": (\n\"fullTemplateTypeCheck\": true,\n\"preserveWhitespaces\": true,\n...\n)\n)\n"}, {"question": "92.  How do you specify angular template compiler options?", "answer": "The angular template compiler options are specified as members of the **angularCompilerOptions** object in the tsconfig.json file. These options will be specified adjecent to typescript compiler options.\n\n\n\n", "code": "(\n\"compilerOptions\": (\n\"experimentalDecorators\": true,\n...\n),\n\"angularCompilerOptions\": (\n\"fullTemplateTypeCheck\": true,\n\"preserveWhitespaces\": true,\n...\n)\n)\n"}, {"question": "93.  How do you enable binding expression validation?", "answer": "You can enable binding expression validation explicitly by adding the compiler option **fullTemplateTypeCheck** in the \"angularCompilerOptions\" of the project's tsconfig.json. It produces error messages when a type error is detected in a template binding expression.\n\nFor example, consider the following component:\nThis will produce the following error:\n\n\n", "code": "@Component((\nselector: 'my-component',\ntemplate: '((user.contacts.email))'\n))\nclass MyComponent (\nuser?: User;\n)\nmy.component.ts.MyComponent.html(1,1): : Property 'contacts' does not exist on type 'User'. Did you mean 'contact'?\n"}, {"question": "94.  What is the purpose of any type cast function?", "answer": "You can disable binding expression type checking using $any() type cast function(by surrounding the expression). In the following example, the error Property contacts does not exist is suppressed by casting user to the any type.\nThe $any() cast function also works with this to allow access to undeclared members of the component.\n\n\n", "code": "template:\n'(( $any(user).contacts.email ))'\ntemplate:\n'(( $any(this).contacts.email ))'\n"}, {"question": "95.  What is Non null type assertion operator?", "answer": "You can use the non-null type assertion operator to suppress the Object is possibly 'undefined' error. In the following example, the user and contact properties are always set together, implying that contact is always non-null if user is non-null. The error is suppressed in the example by using contact!.email.\n\n\n", "code": "@Component((\nselector: 'my-component',\ntemplate: '<span *ngIf=\"user\"> ((user.name)) contacted through ((contact!.email)) </span>'\n))\nclass MyComponent (\nuser?: User;\ncontact?: Contact;\n\nsetData(user: User, contact: Contact) (\nthis.user = user;\nthis.contact = contact;\n)\n)\n"}, {"question": "96.  What is type narrowing?", "answer": "The expression used in an ngIf directive is used to narrow type unions in the Angular template compiler similar to if expression in typescript. So *ngIf allows the typeScript compiler to infer that the data used in the binding expression will never be undefined.\n\n\n", "code": "@Component((\nselector: 'my-component',\ntemplate: '<span *ngIf=\"user\"> ((user.contact.email)) </span>'\n))\nclass MyComponent (\nuser?: User;\n)\n"}, {"question": "97.  How do you describe various dependencies in angular application?", "answer": "The dependencies section of package.json with in an angular application can be divided as follow,\n\n1. **Angular packages:** Angular core and optional modules; their package names begin @angular/.\n2. **Support packages:** Third-party libraries that must be present for Angular apps to run.\n3. **Polyfill packages:** Polyfills plug gaps in a browser's JavaScript implementation.\n\n\n", "code": ""}, {"question": "98.  What is zone?", "answer": "A Zone is an execution context that persists across async tasks. Angular relies on zone.js to run Angular's change detection processes when native JavaScript operations raise events\n\n\n", "code": ""}, {"question": "99.  What is the purpose of common module?", "answer": "The commonly-needed services, pipes, and directives provided by @angular/common module. Apart from these HttpClientModule is available under @angular/common/http.\n\n\n", "code": ""}, {"question": "100.  What is codelyzer?", "answer": "Codelyzer provides set of tslint rules for static code analysis of Angular TypeScript projects. You can run the static code analyzer over web apps, NativeScript, Ionic etc. Angular CLI has support for this and it can be use as below,\n\n\n", "code": "ng new codelyzer\nng lint\n"}]
